<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IteratorUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Collections</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4</a> &gt; <span class="el_source">IteratorUtils.java</span></div><h1>IteratorUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Objects;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.function.IntFunction;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.apache.commons.collections4.functors.EqualPredicate;
import org.apache.commons.collections4.iterators.ArrayIterator;
import org.apache.commons.collections4.iterators.ArrayListIterator;
import org.apache.commons.collections4.iterators.BoundedIterator;
import org.apache.commons.collections4.iterators.CollatingIterator;
import org.apache.commons.collections4.iterators.EmptyIterator;
import org.apache.commons.collections4.iterators.EmptyListIterator;
import org.apache.commons.collections4.iterators.EmptyMapIterator;
import org.apache.commons.collections4.iterators.EmptyOrderedIterator;
import org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;
import org.apache.commons.collections4.iterators.EnumerationIterator;
import org.apache.commons.collections4.iterators.FilterIterator;
import org.apache.commons.collections4.iterators.FilterListIterator;
import org.apache.commons.collections4.iterators.IteratorChain;
import org.apache.commons.collections4.iterators.IteratorEnumeration;
import org.apache.commons.collections4.iterators.IteratorIterable;
import org.apache.commons.collections4.iterators.LazyIteratorChain;
import org.apache.commons.collections4.iterators.ListIteratorWrapper;
import org.apache.commons.collections4.iterators.LoopingIterator;
import org.apache.commons.collections4.iterators.LoopingListIterator;
import org.apache.commons.collections4.iterators.NodeListIterator;
import org.apache.commons.collections4.iterators.ObjectArrayIterator;
import org.apache.commons.collections4.iterators.ObjectArrayListIterator;
import org.apache.commons.collections4.iterators.ObjectGraphIterator;
import org.apache.commons.collections4.iterators.PeekingIterator;
import org.apache.commons.collections4.iterators.PushbackIterator;
import org.apache.commons.collections4.iterators.SingletonIterator;
import org.apache.commons.collections4.iterators.SingletonListIterator;
import org.apache.commons.collections4.iterators.SkippingIterator;
import org.apache.commons.collections4.iterators.TransformIterator;
import org.apache.commons.collections4.iterators.UnmodifiableIterator;
import org.apache.commons.collections4.iterators.UnmodifiableListIterator;
import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;
import org.apache.commons.collections4.iterators.ZippingIterator;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * Provides static utility methods and decorators for {@link Iterator}
 * instances. The implementations are provided in the iterators subpackage.
 *
 * @since 2.1
 */
public class IteratorUtils {
    // validation is done in this class in certain cases because the
    // public classes allow invalid states

    /**
     * An iterator over no elements.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L88">    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;</span>

    /**
     * A list iterator over no elements.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L94">    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;</span>

    /**
     * An ordered iterator over no elements.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L100">    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;</span>

    /**
     * A map iterator over no elements.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L106">    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;</span>

    /**
     * An ordered map iterator over no elements.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L112">    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;</span>
    /**
     * Default delimiter used to delimit elements while converting an Iterator
     * to its String representation.
     */
    private static final String DEFAULT_TOSTRING_DELIMITER = &quot;, &quot;;

    /**
     * Gets an iterator over an object array.
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @return an iterator over the array
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; arrayIterator(final E... array) {
<span class="fc" id="L128">        return new ObjectArrayIterator&lt;&gt;(array);</span>
    }

    /**
     * Gets an iterator over the end part of an object array.
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return an iterator over part of the array
     * @throws IndexOutOfBoundsException if start is less than zero or greater
     *   than the length of the array
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; arrayIterator(final E[] array, final int start) {
<span class="fc" id="L143">        return new ObjectArrayIterator&lt;&gt;(array, start);</span>
    }

    /**
     * Gets an iterator over part of an object array.
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return an iterator over part of the array
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws IllegalArgumentException if end is before start
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; arrayIterator(final E[] array, final int start, final int end) {
<span class="fc" id="L159">        return new ObjectArrayIterator&lt;&gt;(array, start, end);</span>
    }

    /**
     * Gets an iterator over an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @return an iterator over the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; arrayIterator(final Object array) {
<span class="fc" id="L176">        return new ArrayIterator&lt;&gt;(array);</span>
    }

    /**
     * Gets an iterator over the end part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return an iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws IndexOutOfBoundsException if start is less than zero or greater
     *   than the length of the array
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; arrayIterator(final Object array, final int start) {
<span class="fc" id="L196">        return new ArrayIterator&lt;&gt;(array, start);</span>
    }

    /**
     * Gets an iterator over part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return an iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array or end is before start
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; arrayIterator(final Object array, final int start, final int end) {
<span class="fc" id="L216">        return new ArrayIterator&lt;&gt;(array, start, end);</span>
    }

    /**
     * Gets a list iterator over an object array.
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @return a list iterator over the array
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; arrayListIterator(final E... array) {
<span class="fc" id="L228">        return new ObjectArrayListIterator&lt;&gt;(array);</span>
    }

    /**
     * Gets a list iterator over the end part of an object array.
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return a list iterator over part of the array
     * @throws IndexOutOfBoundsException if start is less than zero
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; arrayListIterator(final E[] array, final int start) {
<span class="fc" id="L242">        return new ObjectArrayListIterator&lt;&gt;(array, start);</span>
    }

    /**
     * Gets a list iterator over part of an object array.
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return a list iterator over part of the array
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws IllegalArgumentException if end is before start
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; arrayListIterator(final E[] array, final int start, final int end) {
<span class="fc" id="L258">        return new ObjectArrayListIterator&lt;&gt;(array, start, end);</span>
    }

    /**
     * Gets a list iterator over an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @return a list iterator over the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; arrayListIterator(final Object array) {
<span class="fc" id="L275">        return new ArrayListIterator&lt;&gt;(array);</span>
    }

    /**
     * Gets a list iterator over the end part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return a list iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws IndexOutOfBoundsException if start is less than zero
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; arrayListIterator(final Object array, final int start) {
<span class="fc" id="L294">        return new ArrayListIterator&lt;&gt;(array, start);</span>
    }

    /**
     * Gets a list iterator over part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return a list iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array or end is before start
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws NullPointerException if array is null
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; arrayListIterator(final Object array, final int start, final int end) {
<span class="fc" id="L314">        return new ArrayListIterator&lt;&gt;(array, start, end);</span>
    }

    /**
     * Gets an enumeration that wraps an iterator.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, may not be null
     * @return a new enumeration
     * @throws NullPointerException if iterator is null
     */
    public static &lt;E&gt; Enumeration&lt;E&gt; asEnumeration(final Iterator&lt;? extends E&gt; iterator) {
<span class="fc" id="L326">        return new IteratorEnumeration&lt;&gt;(Objects.requireNonNull(iterator, &quot;iterator&quot;));</span>
    }

    /**
     * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be
     * used for a single iteration.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, may not be null
     * @return a new, single use {@link Iterable}
     * @throws NullPointerException if iterator is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; asIterable(final Iterator&lt;? extends E&gt; iterator) {
<span class="fc" id="L339">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc" id="L340">        return new IteratorIterable&lt;&gt;(iterator, false);</span>
    }

    /**
     * Gets an iterator that provides an iterator view of the given enumeration.
     *
     * @param &lt;E&gt; the element type
     * @param enumeration  the enumeration to use, may not be null
     * @return a new iterator
     * @throws NullPointerException if enumeration is null
     */
    public static &lt;E&gt; Iterator&lt;E&gt; asIterator(final Enumeration&lt;? extends E&gt; enumeration) {
<span class="fc" id="L352">        return new EnumerationIterator&lt;&gt;(Objects.requireNonNull(enumeration, &quot;enumeration&quot;));</span>
    }

    /**
     * Gets an iterator that provides an iterator view of the given enumeration
     * that will remove elements from the specified collection.
     *
     * @param &lt;E&gt; the element type
     * @param enumeration  the enumeration to use, may not be null
     * @param removeCollection  the collection to remove elements from, may not be null
     * @return a new iterator
     * @throws NullPointerException if enumeration or removeCollection is null
     */
    public static &lt;E&gt; Iterator&lt;E&gt; asIterator(final Enumeration&lt;? extends E&gt; enumeration,
                                             final Collection&lt;? super E&gt; removeCollection) {
<span class="fc" id="L367">        return new EnumerationIterator&lt;&gt;(Objects.requireNonNull(enumeration, &quot;enumeration&quot;),</span>
<span class="fc" id="L368">                Objects.requireNonNull(removeCollection, &quot;removeCollection&quot;));</span>
    }

    /**
     * Gets an iterable that wraps an iterator.  The returned iterable can be
     * used for multiple iterations.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, may not be null
     * @return a new, multiple use iterable
     * @throws NullPointerException if iterator is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; asMultipleUseIterable(final Iterator&lt;? extends E&gt; iterator) {
<span class="fc" id="L381">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc" id="L382">        return new IteratorIterable&lt;&gt;(iterator, true);</span>
    }

    // Bounded
    /**
     * Decorates the specified iterator to return at most the given number
     * of elements.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to decorate
     * @param max  the maximum number of elements returned by this iterator
     * @return a new bounded iterator
     * @throws NullPointerException if the iterator is null
     * @throws IllegalArgumentException if max is negative
     * @since 4.1
     */
    public static &lt;E&gt; BoundedIterator&lt;E&gt; boundedIterator(final Iterator&lt;? extends E&gt; iterator, final long max) {
<span class="fc" id="L399">        return boundedIterator(iterator, 0, max);</span>
    }

    /**
     * Decorates the specified iterator to return at most the given number
     * of elements, skipping all elements until the iterator reaches the
     * position at {@code offset}.
     * &lt;p&gt;
     * The iterator is immediately advanced until it reaches the position at
     * {@code offset}, incurring O(n) time.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to decorate
     * @param offset  the index of the first element of the decorated iterator to return
     * @param max  the maximum number of elements returned by this iterator
     * @return a new bounded iterator
     * @throws NullPointerException if the iterator is null
     * @throws IllegalArgumentException if either offset or max is negative
     * @since 4.1
     */
    public static &lt;E&gt; BoundedIterator&lt;E&gt; boundedIterator(final Iterator&lt;? extends E&gt; iterator,
                                                         final long offset, final long max) {
<span class="fc" id="L422">        return new BoundedIterator&lt;&gt;(iterator, offset, max);</span>
    }

    /**
     * Gets an iterator that iterates through a collections of {@link Iterator}s
     * one after another.
     *
     * @param &lt;E&gt; the element type
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators collection is null or contains a null
     * @throws ClassCastException if the iterators collection contains the wrong object type
     */
    public static &lt;E&gt; Iterator&lt;E&gt; chainedIterator(final Collection&lt;? extends Iterator&lt;? extends E&gt;&gt; iterators) {
<span class="fc" id="L436">        return new IteratorChain&lt;&gt;(iterators);</span>
    }

    /**
     * Gets an iterator that iterates through an array of {@link Iterator}s
     * one after another.
     *
     * @param &lt;E&gt; the element type
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators array is null or contains a null
     */
    public static &lt;E&gt; Iterator&lt;E&gt; chainedIterator(final Iterator&lt;? extends E&gt;... iterators) {
<span class="fc" id="L449">        return new IteratorChain&lt;&gt;(iterators);</span>
    }

    /**
     * Gets an iterator that iterates through two {@link Iterator}s
     * one after another.
     *
     * @param &lt;E&gt; the element type
     * @param iterator1  the first iterator to use, not null
     * @param iterator2  the second iterator to use, not null
     * @return a combination iterator over the iterators
     * @throws NullPointerException if either iterator is null
     */
    public static &lt;E&gt; Iterator&lt;E&gt; chainedIterator(final Iterator&lt;? extends E&gt; iterator1,
                                                  final Iterator&lt;? extends E&gt; iterator2) {
        // keep a version with two iterators to avoid the following warning in client code (Java 5 &amp; 6)
        // &quot;A generic array of E is created for a varargs parameter&quot;
<span class="fc" id="L466">        return new IteratorChain&lt;&gt;(iterator1, iterator2);</span>
    }

    /**
     * Gets an iterator that iterates through an {@link Iterator} of Iterators one after another.
     *
     * @param &lt;E&gt;       the element type
     * @param iterators the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators collection is null or contains a null
     * @throws ClassCastException   if the iterators collection contains the wrong object type
     * @since 4.5.0-M3
     */
    public static &lt;E&gt; Iterator&lt;E&gt; chainedIterator(final Iterator&lt;? extends Iterator&lt;? extends E&gt;&gt; iterators) {
<span class="fc" id="L480">        return new LazyIteratorChain&lt;E&gt;() {</span>

            @Override
            protected Iterator&lt;? extends E&gt; nextIterator(final int count) {
<span class="fc bfc" id="L484" title="All 2 branches covered.">                return iterators.hasNext() ? iterators.next() : null;</span>
            }

        };
    }

    /**
     * Gets an iterator that provides an ordered iteration over the elements
     * contained in a collection of {@link Iterator}s.
     * &lt;p&gt;
     * Given two ordered {@link Iterator}s {@code A} and {@code B},
     * the {@link Iterator#next()} method will return the lesser of
     * {@code A.next()} and {@code B.next()} and so on.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The comparator is optional. If null is specified then natural order is used.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param comparator  the comparator to use, may be null for natural order
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators collection is null or contains a null
     * @throws ClassCastException if the iterators collection contains the wrong object type
     */
    public static &lt;E&gt; Iterator&lt;E&gt; collatedIterator(final Comparator&lt;? super E&gt; comparator,
                                                   final Collection&lt;Iterator&lt;? extends E&gt;&gt; iterators) {
        @SuppressWarnings(&quot;unchecked&quot;)
        final Comparator&lt;E&gt; comp =
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator&lt;E&gt;) comparator;</span>
<span class="fc" id="L514">        return new CollatingIterator&lt;&gt;(comp, iterators);</span>
    }

    /**
     * Gets an iterator that provides an ordered iteration over the elements
     * contained in an array of {@link Iterator}s.
     * &lt;p&gt;
     * Given two ordered {@link Iterator}s {@code A} and {@code B},
     * the {@link Iterator#next()} method will return the lesser of
     * {@code A.next()} and {@code B.next()} and so on.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The comparator is optional. If null is specified then natural order is used.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param comparator  the comparator to use, may be null for natural order
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators array is null or contains a null value
     */
    public static &lt;E&gt; Iterator&lt;E&gt; collatedIterator(final Comparator&lt;? super E&gt; comparator,
                                                   final Iterator&lt;? extends E&gt;... iterators) {
        @SuppressWarnings(&quot;unchecked&quot;)
        final Comparator&lt;E&gt; comp =
<span class="fc bfc" id="L539" title="All 2 branches covered.">            comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator&lt;E&gt;) comparator;</span>
<span class="fc" id="L540">        return new CollatingIterator&lt;&gt;(comp, iterators);</span>
    }

    /**
     * Gets an iterator that provides an ordered iteration over the elements
     * contained in a collection of ordered {@link Iterator}s.
     * &lt;p&gt;
     * Given two ordered {@link Iterator}s {@code A} and {@code B},
     * the {@link Iterator#next()} method will return the lesser of
     * {@code A.next()} and {@code B.next()}.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The comparator is optional. If null is specified then natural order is used.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param comparator  the comparator to use, may be null for natural order
     * @param iterator1  the first iterators to use, not null
     * @param iterator2  the first iterators to use, not null
     * @return a combination iterator over the iterators
     * @throws NullPointerException if either iterator is null
     */
    public static &lt;E&gt; Iterator&lt;E&gt; collatedIterator(final Comparator&lt;? super E&gt; comparator,
                                                   final Iterator&lt;? extends E&gt; iterator1,
                                                   final Iterator&lt;? extends E&gt; iterator2) {
        @SuppressWarnings(&quot;unchecked&quot;)
        final Comparator&lt;E&gt; comp =
<span class="fc bfc" id="L567" title="All 2 branches covered.">            comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator&lt;E&gt;) comparator;</span>
<span class="fc" id="L568">        return new CollatingIterator&lt;&gt;(comp, iterator1, iterator2);</span>
    }

    /**
     * Checks if the object is contained in the given iterator.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns false.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterator} contains
     * @param iterator  the iterator to check, may be null
     * @param object  the object to check
     * @return true if the object is contained in the iterator, false otherwise
     * @since 4.1
     */
    public static &lt;E&gt; boolean contains(final Iterator&lt;E&gt; iterator, final Object object) {
<span class="fc" id="L584">        return matchesAny(iterator, EqualPredicate.equalPredicate(object));</span>
    }

    /**
     * Gets an empty iterator.
     * &lt;p&gt;
     * This iterator is a valid iterator object that will iterate over nothing.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @return an iterator over nothing
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; emptyIterator() {
<span class="fc" id="L597">        return EmptyIterator.&lt;E&gt;resettableEmptyIterator();</span>
    }

    /**
     * Gets an empty list iterator.
     * &lt;p&gt;
     * This iterator is a valid list iterator object that will iterate
     * over nothing.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @return a list iterator over nothing
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; emptyListIterator() {
<span class="fc" id="L611">        return EmptyListIterator.&lt;E&gt;resettableEmptyListIterator();</span>
    }

    /**
     * Gets an empty map iterator.
     * &lt;p&gt;
     * This iterator is a valid map iterator object that will iterate
     * over nothing.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @return a map iterator over nothing
     */
    public static &lt;K, V&gt; MapIterator&lt;K, V&gt; emptyMapIterator() {
<span class="fc" id="L626">        return EmptyMapIterator.&lt;K, V&gt;emptyMapIterator();</span>
    }

    /**
     * Gets an empty ordered iterator.
     * &lt;p&gt;
     * This iterator is a valid iterator object that will iterate
     * over nothing.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @return an ordered iterator over nothing
     */
    public static &lt;E&gt; OrderedIterator&lt;E&gt; emptyOrderedIterator() {
<span class="fc" id="L640">        return EmptyOrderedIterator.&lt;E&gt;emptyOrderedIterator();</span>
    }

    /**
     * Gets an empty ordered map iterator.
     * &lt;p&gt;
     * This iterator is a valid map iterator object that will iterate
     * over nothing.
     * &lt;/p&gt;
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @return a map iterator over nothing
     */
    public static &lt;K, V&gt; OrderedMapIterator&lt;K, V&gt; emptyOrderedMapIterator() {
<span class="fc" id="L655">        return EmptyOrderedMapIterator.&lt;K, V&gt;emptyOrderedMapIterator();</span>
    }

    /**
     * Gets an iterator that filters another iterator.
     * &lt;p&gt;
     * The returned iterator will only return objects that match the specified
     * filtering predicate.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, not null
     * @param predicate  the predicate to use as a filter, not null
     * @return a new filtered iterator
     * @throws NullPointerException if either parameter is null
     */
    public static &lt;E&gt; Iterator&lt;E&gt; filteredIterator(final Iterator&lt;? extends E&gt; iterator,
                                                   final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L673">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc" id="L674">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc" id="L675">        return new FilterIterator&lt;&gt;(iterator, predicate);</span>
    }

    /**
     * Gets a list iterator that filters another list iterator.
     * &lt;p&gt;
     * The returned iterator will only return objects that match the specified
     * filtering predicate.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param listIterator  the list iterator to use, not null
     * @param predicate  the predicate to use as a filter, not null
     * @return a new filtered iterator
     * @throws NullPointerException if either parameter is null
     */
    public static &lt;E&gt; ListIterator&lt;E&gt; filteredListIterator(final ListIterator&lt;? extends E&gt; listIterator,
            final Predicate&lt;? super E&gt; predicate) {

<span class="fc" id="L694">        Objects.requireNonNull(listIterator, &quot;listIterator&quot;);</span>
<span class="fc" id="L695">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc" id="L696">        return new FilterListIterator&lt;&gt;(listIterator, predicate);</span>
    }

    /**
     * Finds the first element in the given iterator which matches the given predicate.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns null.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to search, may be null
     * @param predicate  the predicate to use, must not be null
     * @return the first element of the iterator which matches the predicate or null if none could be found
     * @throws NullPointerException if predicate is null
     * @since 4.1
     */
    public static &lt;E&gt; E find(final Iterator&lt;E&gt; iterator, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L713">        return find(iterator, predicate, null);</span>
    }

    /**
     * Finds the first element in the given iterator which matches the given predicate.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns {@code defaultValue}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt;          the element type.
     * @param iterator     the iterator to search, may be null.
     * @param predicate    the predicate to use, must not be null.
     * @param defaultValue the default value, may be null.
     * @return the first element of the iterator which matches the predicate or null if none could be found.
     * @throws NullPointerException if predicate is null.
     */
    private static &lt;E&gt; E find(final Iterator&lt;E&gt; iterator, final Predicate&lt;? super E&gt; predicate, final E defaultValue) {
<span class="fc" id="L730">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (iterator != null) {</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L733">                final E element = iterator.next();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                if (predicate.test(element)) {</span>
<span class="fc" id="L735">                    return element;</span>
                }
<span class="fc" id="L737">            }</span>
        }
<span class="fc" id="L739">        return defaultValue;</span>
    }

    /**
     * Shortcut for {@code get(iterator, 0)}.
     * &lt;p&gt;
     * Returns the {@code first} value in {@link Iterator}, throwing
     * {@code IndexOutOfBoundsException} if there is no such element.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The Iterator is advanced to {@code 0} (or to the end, if
     * {@code 0} exceeds the number of entries) as a side effect of this method.
     * &lt;/p&gt;
     * @param &lt;E&gt; the type of object in the {@link Iterator}
     * @param iterator the iterator to get a value from
     * @return the first object
     * @throws IndexOutOfBoundsException if the request is invalid
     * @since 4.2
     */
    public static &lt;E&gt; E first(final Iterator&lt;E&gt; iterator) {
<span class="fc" id="L759">        return get(iterator, 0);</span>
    }

    /**
     * Applies the closure to each element of the provided iterator.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, may be null
     * @param closure  the closure to apply to each element, may not be null
     * @throws NullPointerException if closure is null
     * @since 4.1
     */
    public static &lt;E&gt; void forEach(final Iterator&lt;E&gt; iterator, final Closure&lt;? super E&gt; closure) {
<span class="fc" id="L772">        Objects.requireNonNull(closure, &quot;closure&quot;);</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">        if (iterator != null) {</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L775">                closure.accept(iterator.next());</span>
            }
        }
<span class="fc" id="L778">    }</span>

    /**
     * Executes the given closure on each but the last element in the iterator.
     * &lt;p&gt;
     * If the input iterator is null no change is made.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterator} contains
     * @param iterator  the iterator to get the input from, may be null
     * @param closure  the closure to perform, may not be null
     * @return the last element in the iterator, or null if iterator is null or empty
     * @throws NullPointerException if closure is null
     * @since 4.1
     */
    public static &lt;E&gt; E forEachButLast(final Iterator&lt;E&gt; iterator, final Closure&lt;? super E&gt; closure) {
<span class="fc" id="L794">        Objects.requireNonNull(closure, &quot;closure&quot;);</span>

<span class="fc bfc" id="L796" title="All 2 branches covered.">        if (iterator != null) {</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L798">                final E element = iterator.next();</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">                if (!iterator.hasNext()) {</span>
<span class="fc" id="L800">                    return element;</span>
                }
<span class="fc" id="L802">                closure.accept(element);</span>
<span class="fc" id="L803">            }</span>
        }
<span class="fc" id="L805">        return null;</span>
    }

    /**
     * Gets the {@code index}-th value in {@link Iterator}, throwing {@code IndexOutOfBoundsException} if there is no such element.
     * &lt;p&gt;
     * The Iterator is advanced to {@code index} (or to the end, if {@code index} exceeds the number of entries) as a side effect of this method.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt;      the type of object in the {@link Iterator}.
     * @param iterator the iterator to get a value from.
     * @param index    the index to get, 0-based.
     * @return the object at the specified index.
     * @throws IndexOutOfBoundsException if the index is invalid.
     * @since 4.1
     */
    public static &lt;E&gt; E get(final Iterator&lt;E&gt; iterator, final int index) {
<span class="fc" id="L822">        return get(iterator, index, ioob -&gt; {</span>
<span class="fc" id="L823">            throw new IndexOutOfBoundsException(&quot;Entry does not exist: &quot; + ioob);</span>
        });
    }

    /**
     * Gets the {@code index}-th value in {@link Iterator}, throwing {@code IndexOutOfBoundsException} if there is no such element.
     * &lt;p&gt;
     * The Iterator is advanced to {@code index} (or to the end, if {@code index} exceeds the number of entries) as a side effect of this method.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt;             the type of object in the {@link Iterator}
     * @param iterator        the iterator to get a value from
     * @param index           the index to get, 0-based.
     * @param defaultSupplier supplies a default value at an index.
     * @return the object at the specified index
     * @throws IndexOutOfBoundsException if the index is invalid
     */
    static &lt;E&gt; E get(final Iterator&lt;E&gt; iterator, final int index, final IntFunction&lt;E&gt; defaultSupplier) {
<span class="fc" id="L841">        int i = index;</span>
<span class="fc" id="L842">        CollectionUtils.checkIndexBounds(i);</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L844">            i--;</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">            if (i == -1) {</span>
<span class="fc" id="L846">                return iterator.next();</span>
            }
<span class="fc" id="L848">            iterator.next();</span>
        }
<span class="fc" id="L850">        return defaultSupplier.apply(i);</span>
    }

    /**
     * Gets a suitable Iterator for the given object.
     * &lt;p&gt;
     * This method can handle objects as follows
     * &lt;/p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;null - empty iterator
     * &lt;li&gt;Iterator - returned directly
     * &lt;li&gt;Enumeration - wrapped
     * &lt;li&gt;Collection - iterator from collection returned
     * &lt;li&gt;Map - values iterator returned
     * &lt;li&gt;Dictionary - values (elements) enumeration returned as iterator
     * &lt;li&gt;array - iterator over array returned
     * &lt;li&gt;object with iterator() public method accessed by reflection
     * &lt;li&gt;object - singleton iterator
     * &lt;li&gt;NodeList - iterator over the list
     * &lt;li&gt;Node - iterator over the child nodes
     * &lt;/ul&gt;
     *
     * @param obj  the object to convert to an iterator
     * @return a suitable iterator, never null
     */
    public static Iterator&lt;?&gt; getIterator(final Object obj) {
<span class="fc bfc" id="L876" title="All 2 branches covered.">        if (obj == null) {</span>
<span class="fc" id="L877">            return emptyIterator();</span>
        }
<span class="fc bfc" id="L879" title="All 2 branches covered.">        if (obj instanceof Iterator) {</span>
<span class="fc" id="L880">            return (Iterator&lt;?&gt;) obj;</span>
        }
<span class="fc bfc" id="L882" title="All 2 branches covered.">        if (obj instanceof Iterable) {</span>
<span class="fc" id="L883">            return ((Iterable&lt;?&gt;) obj).iterator();</span>
        }
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if (obj instanceof Object[]) {</span>
<span class="fc" id="L886">            return new ObjectArrayIterator&lt;&gt;((Object[]) obj);</span>
        }
<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (obj instanceof Enumeration) {</span>
<span class="fc" id="L889">            return new EnumerationIterator&lt;&gt;((Enumeration&lt;?&gt;) obj);</span>
        }
<span class="fc bfc" id="L891" title="All 2 branches covered.">        if (obj instanceof Map) {</span>
<span class="fc" id="L892">            return ((Map&lt;?, ?&gt;) obj).values().iterator();</span>
        }
<span class="fc bfc" id="L894" title="All 2 branches covered.">        if (obj instanceof NodeList) {</span>
<span class="fc" id="L895">            return new NodeListIterator((NodeList) obj);</span>
        }
<span class="fc bfc" id="L897" title="All 2 branches covered.">        if (obj instanceof Node) {</span>
<span class="fc" id="L898">            return new NodeListIterator((Node) obj);</span>
        }
<span class="fc bfc" id="L900" title="All 2 branches covered.">        if (obj instanceof Dictionary) {</span>
<span class="fc" id="L901">            return new EnumerationIterator&lt;&gt;(((Dictionary&lt;?, ?&gt;) obj).elements());</span>
        }
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">        if (obj.getClass().isArray()) {</span>
<span class="fc" id="L904">            return new ArrayIterator&lt;&gt;(obj);</span>
        }
        try {
<span class="nc" id="L907">            final Method method = obj.getClass().getMethod(&quot;iterator&quot;, (Class[]) null);</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (Iterator.class.isAssignableFrom(method.getReturnType())) {</span>
<span class="nc" id="L909">                final Iterator&lt;?&gt; it = (Iterator&lt;?&gt;) method.invoke(obj, (Object[]) null);</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                if (it != null) {</span>
<span class="nc" id="L911">                    return it;</span>
                }
            }
<span class="nc" id="L914">        } catch (final RuntimeException | ReflectiveOperationException ignore) { // NOPMD</span>
            // ignore
<span class="nc" id="L916">        }</span>
<span class="nc" id="L917">        return singletonIterator(obj);</span>
    }

    /**
     * Returns the index of the first element in the specified iterator that
     * matches the given predicate.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns -1.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to search, may be null
     * @param predicate  the predicate to use, may not be null
     * @return the index of the first element which matches the predicate or -1 if none matches
     * @throws NullPointerException if predicate is null
     * @since 4.1
     */
    public static &lt;E&gt; int indexOf(final Iterator&lt;E&gt; iterator, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L935">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>

<span class="fc bfc" id="L937" title="All 2 branches covered.">        if (iterator != null) {</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">            for (int index = 0; iterator.hasNext(); index++) {</span>
<span class="fc" id="L939">                final E element = iterator.next();</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">                if (predicate.test(element)) {</span>
<span class="fc" id="L941">                    return index;</span>
                }
            }
        }
<span class="fc" id="L945">        return CollectionUtils.INDEX_NOT_FOUND;</span>
    }

    /**
     * Checks if the given iterator is empty.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns true.
     * &lt;/p&gt;
     *
     * @param iterator  the {@link Iterator} to use, may be null
     * @return true if the iterator is exhausted or null, false otherwise
     * @since 4.1
     */
    public static boolean isEmpty(final Iterator&lt;?&gt; iterator) {
<span class="pc bpc" id="L959" title="1 of 4 branches missed.">        return iterator == null || !iterator.hasNext();</span>
    }

    /**
     * Gets an iterator that loops continuously over the supplied collection.
     * &lt;p&gt;
     * The iterator will only stop looping if the remove method is called
     * enough times to empty the collection, or if the collection is empty
     * to start with.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param collection  the collection to iterate over, not null
     * @return a new looping iterator
     * @throws NullPointerException if the collection is null
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; loopingIterator(final Collection&lt;? extends E&gt; collection) {
<span class="fc" id="L976">        return new LoopingIterator&lt;&gt;(Objects.requireNonNull(collection, &quot;collection&quot;));</span>
    }

    /**
     * Gets an iterator that loops continuously over the supplied list.
     * &lt;p&gt;
     * The iterator will only stop looping if the remove method is called
     * enough times to empty the list, or if the list is empty to start with.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param list  the list to iterate over, not null
     * @return a new looping iterator
     * @throws NullPointerException if the list is null
     * @since 3.2
     */
    public static &lt;E&gt; ResettableListIterator&lt;E&gt; loopingListIterator(final List&lt;E&gt; list) {
<span class="fc" id="L993">        return new LoopingListIterator&lt;&gt;(Objects.requireNonNull(list, &quot;list&quot;));</span>
    }

    /**
     * Answers true if a predicate is true for every element of an iterator.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns true.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterator} contains
     * @param iterator  the {@link Iterator} to use, may be null
     * @param predicate  the predicate to use, may not be null
     * @return true if every element of the collection matches the predicate or if the
     *   collection is empty, false otherwise
     * @throws NullPointerException if predicate is null
     * @since 4.1
     */
    public static &lt;E&gt; boolean matchesAll(final Iterator&lt;E&gt; iterator, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L1011">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>

<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">        if (iterator != null) {</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L1015">                final E element = iterator.next();</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">                if (!predicate.test(element)) {</span>
<span class="fc" id="L1017">                    return false;</span>
                }
<span class="fc" id="L1019">            }</span>
        }
<span class="fc" id="L1021">        return true;</span>
    }

    /**
     * Answers true if a predicate is true for any element of the iterator.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns false.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterator} contains
     * @param iterator  the {@link Iterator} to use, may be null
     * @param predicate  the predicate to use, may not be null
     * @return true if any element of the collection matches the predicate, false otherwise
     * @throws NullPointerException if predicate is null
     * @since 4.1
     */
    public static &lt;E&gt; boolean matchesAny(final Iterator&lt;E&gt; iterator, final Predicate&lt;? super E&gt; predicate) {
<span class="fc bfc" id="L1038" title="All 2 branches covered.">        return indexOf(iterator, predicate) != -1;</span>
    }

    /**
     * Gets an {@link Iterator} that wraps the specified node's childNodes.
     * The returned {@link Iterator} can be used for a single iteration.
     * &lt;p&gt;
     * Convenience method, allows easy iteration over NodeLists:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *   Iterator&amp;lt;Node&amp;gt; iterator = IteratorUtils.nodeListIterator(node);
     *   for (Node childNode : IteratorUtils.asIterable(iterator)) {
     *     ...
     *   }
     * &lt;/pre&gt;
     *
     * @param node  the node to use, may not be null
     * @return a new, single use {@link Iterator}
     * @throws NullPointerException if node is null
     * @since 4.0
     */
    public static NodeListIterator nodeListIterator(final Node node) {
<span class="fc" id="L1060">        return new NodeListIterator(Objects.requireNonNull(node, &quot;node&quot;));</span>
    }

    /**
     * Gets an {@link Iterator} that wraps the specified {@link NodeList}.
     * The returned {@link Iterator} can be used for a single iteration.
     *
     * @param nodeList  the node list to use, may not be null
     * @return a new, single use {@link Iterator}
     * @throws NullPointerException if nodeList is null
     * @since 4.0
     */
    public static NodeListIterator nodeListIterator(final NodeList nodeList) {
<span class="fc" id="L1073">        return new NodeListIterator(Objects.requireNonNull(nodeList, &quot;nodeList&quot;));</span>
    }

    /**
     * Gets an iterator that operates over an object graph.
     * &lt;p&gt;
     * This iterator can extract multiple objects from a complex tree-like object graph.
     * The iteration starts from a single root object.
     * It uses a {@code Transformer} to extract the iterators and elements.
     * Its main benefit is that no intermediate {@code List} is created.
     * &lt;/p&gt;
     * &lt;p&gt;
     * For example, consider an object graph:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *                 |- Branch -- Leaf
     *                 |         \- Leaf
     *         |- Tree |         /- Leaf
     *         |       |- Branch -- Leaf
     *  Forest |                 \- Leaf
     *         |       |- Branch -- Leaf
     *         |       |         \- Leaf
     *         |- Tree |         /- Leaf
     *                 |- Branch -- Leaf
     *                 |- Branch -- Leaf&lt;/pre&gt;
     * &lt;p&gt;
     * The following {@code Transformer}, used in this class, will extract all
     * the Leaf objects without creating a combined intermediate list:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * public Object transform(Object input) {
     *   if (input instanceof Forest) {
     *     return ((Forest) input).treeIterator();
     *   }
     *   if (input instanceof Tree) {
     *     return ((Tree) input).branchIterator();
     *   }
     *   if (input instanceof Branch) {
     *     return ((Branch) input).leafIterator();
     *   }
     *   if (input instanceof Leaf) {
     *     return input;
     *   }
     *   throw new ClassCastException();
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Internally, iteration starts from the root object. When next is called,
     * the transformer is called to examine the object. The transformer will return
     * either an iterator or an object. If the object is an Iterator, the next element
     * from that iterator is obtained and the process repeats. If the element is an object
     * it is returned.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Under many circumstances, linking Iterators together in this manner is
     * more efficient (and convenient) than using nested for loops to extract a list.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param root  the root object to start iterating from, null results in an empty iterator
     * @param transformer  the transformer to use, see above, null uses no effect transformer
     * @return a new object graph iterator
     * @since 3.1
     */
    public static &lt;E&gt; Iterator&lt;E&gt; objectGraphIterator(final E root,
            final Transformer&lt;? super E, ? extends E&gt; transformer) {
<span class="fc" id="L1138">        return new ObjectGraphIterator&lt;&gt;(root, transformer);</span>
    }

    /**
     * Gets an iterator that supports one-element lookahead.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to decorate, not null
     * @return a peeking iterator
     * @throws NullPointerException if the iterator is null
     * @since 4.0
     */
    public static &lt;E&gt; Iterator&lt;E&gt; peekingIterator(final Iterator&lt;? extends E&gt; iterator) {
<span class="fc" id="L1151">        return PeekingIterator.peekingIterator(iterator);</span>
    }

    /**
     * Gets an iterator that supports pushback of elements.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to decorate, not null
     * @return a pushback iterator
     * @throws NullPointerException if the iterator is null
     * @since 4.0
     */
    public static &lt;E&gt; Iterator&lt;E&gt; pushbackIterator(final Iterator&lt;? extends E&gt; iterator) {
<span class="fc" id="L1164">        return PushbackIterator.pushbackIterator(iterator);</span>
    }

    /**
     * Gets a singleton iterator.
     * &lt;p&gt;
     * This iterator is a valid iterator object that will iterate over
     * the specified object.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param object  the single object over which to iterate
     * @return a singleton iterator over the object
     */
    public static &lt;E&gt; ResettableIterator&lt;E&gt; singletonIterator(final E object) {
<span class="fc" id="L1179">        return new SingletonIterator&lt;&gt;(object);</span>
    }

    /**
     * Gets a singleton list iterator.
     * &lt;p&gt;
     * This iterator is a valid list iterator object that will iterate over
     * the specified object.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param object  the single object over which to iterate
     * @return a singleton list iterator over the object
     */
    public static &lt;E&gt; ListIterator&lt;E&gt; singletonListIterator(final E object) {
<span class="fc" id="L1194">        return new SingletonListIterator&lt;&gt;(object);</span>
    }

    /**
     * Returns the number of elements contained in the given iterator.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns {@code 0}.
     * &lt;/p&gt;
     *
     * @param iterator  the iterator to check, may be null
     * @return the number of elements contained in the iterator
     * @since 4.1
     */
    public static int size(final Iterator&lt;?&gt; iterator) {
<span class="fc" id="L1208">        int size = 0;</span>
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        if (iterator != null) {</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L1211">                iterator.next();</span>
<span class="fc" id="L1212">                size++;</span>
            }
        }
<span class="fc" id="L1215">        return size;</span>
    }

    /**
     * Decorates the specified iterator to skip the first N elements.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to decorate
     * @param offset  the first number of elements to skip
     * @return a new skipping iterator
     * @throws NullPointerException if the iterator is null
     * @throws IllegalArgumentException if offset is negative
     * @since 4.1
     */
    public static &lt;E&gt; SkippingIterator&lt;E&gt; skippingIterator(final Iterator&lt;E&gt; iterator, final long offset) {
<span class="fc" id="L1230">        return new SkippingIterator&lt;&gt;(iterator, offset);</span>
    }

    /**
     * Creates a stream on the given Iterable.
     *
     * @param &lt;E&gt; the type of elements in the Iterable.
     * @param iterable the Iterable to stream or null.
     * @return a new Stream or {@link Stream#empty()} if the Iterable is null.
     * @since 4.5.0-M3
     */
    public static &lt;E&gt; Stream&lt;E&gt; stream(final Iterable&lt;E&gt; iterable) {
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        return iterable == null ? Stream.empty() : StreamSupport.stream(iterable.spliterator(), false);</span>
    }

    /**
     * Creates a stream on the given Iterator.
     *
     * @param &lt;E&gt; the type of elements in the Iterator.
     * @param iterator the Iterator to stream or null.
     * @return a new Stream or {@link Stream#empty()} if the Iterator is null.
     * @since 4.5.0-M3
     */
    public static &lt;E&gt; Stream&lt;E&gt; stream(final Iterator&lt;E&gt; iterator) {
<span class="nc bnc" id="L1254" title="All 2 branches missed.">        return iterator == null ? Stream.empty() : StreamSupport.stream(Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED), false);</span>
    }

    /**
     * Gets an array based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, this is converted to an array.
     * &lt;/p&gt;
     *
     * @param iterator  the iterator to use, not null
     * @return an array of the iterator contents
     * @throws NullPointerException if iterator parameter is null
     */
    public static Object[] toArray(final Iterator&lt;?&gt; iterator) {
<span class="fc" id="L1269">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc" id="L1270">        final List&lt;?&gt; list = toList(iterator, 100);</span>
<span class="fc" id="L1271">        return list.toArray();</span>
    }

    /**
     * Gets an array based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, this is converted to an array.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, not null
     * @param arrayClass  the class of array to create
     * @return an array of the iterator contents
     * @throws NullPointerException if iterator parameter or arrayClass is null
     * @throws ArrayStoreException if the arrayClass is invalid
     */
    public static &lt;E&gt; E[] toArray(final Iterator&lt;? extends E&gt; iterator, final Class&lt;E&gt; arrayClass) {
<span class="fc" id="L1289">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc" id="L1290">        Objects.requireNonNull(arrayClass, &quot;arrayClass&quot;);</span>
<span class="fc" id="L1291">        final List&lt;E&gt; list = toList(iterator, 100);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1293">        final E[] array = (E[]) Array.newInstance(arrayClass, list.size());</span>
<span class="fc" id="L1294">        return list.toArray(array);</span>
    }

    /**
     * Gets a list based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, the list is returned.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, not null
     * @return a list of the iterator contents
     * @throws NullPointerException if iterator parameter is null
     */
    public static &lt;E&gt; List&lt;E&gt; toList(final Iterator&lt;? extends E&gt; iterator) {
<span class="fc" id="L1310">        return toList(iterator, 10);</span>
    }

    /**
     * Gets a list based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, the list is returned.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, not null
     * @param estimatedSize  the initial size of the ArrayList
     * @return a list of the iterator contents
     * @throws NullPointerException if iterator parameter is null
     * @throws IllegalArgumentException if the size is less than 1
     */
    public static &lt;E&gt; List&lt;E&gt; toList(final Iterator&lt;? extends E&gt; iterator, final int estimatedSize) {
<span class="fc" id="L1328">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">        if (estimatedSize &lt; 1) {</span>
<span class="fc" id="L1330">            throw new IllegalArgumentException(&quot;Estimated size must be greater than 0&quot;);</span>
        }
<span class="fc" id="L1332">        final List&lt;E&gt; list = new ArrayList&lt;&gt;(estimatedSize);</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L1334">            list.add(iterator.next());</span>
        }
<span class="fc" id="L1336">        return list;</span>
    }

    /**
     * Gets a list iterator based on a simple iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, a LinkedList of its values is
     * cached, permitting all required operations of ListIterator.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to use, may not be null
     * @return a new iterator
     * @throws NullPointerException if iterator parameter is null
     */
    public static &lt;E&gt; ListIterator&lt;E&gt; toListIterator(final Iterator&lt;? extends E&gt; iterator) {
<span class="fc" id="L1352">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc" id="L1353">        return new ListIteratorWrapper&lt;&gt;(iterator);</span>
    }

    /**
     * Returns a string representation of the elements of the specified iterator.
     * &lt;p&gt;
     * The string representation consists of a list of the iterator's elements,
     * enclosed in square brackets ({@code &quot;[]&quot;}). Adjacent elements are separated
     * by the characters {@code &quot;, &quot;} (a comma followed by a space). Elements are
     * converted to strings as by {@code String.valueOf(Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to convert to a string, may be null
     * @return a string representation of {@code iterator}
     * @since 4.1
     */
    public static &lt;E&gt; String toString(final Iterator&lt;E&gt; iterator) {
<span class="fc" id="L1371">        return toString(iterator, TransformerUtils.stringValueTransformer(),</span>
                        DEFAULT_TOSTRING_DELIMITER, CollectionUtils.DEFAULT_TOSTRING_PREFIX,
                CollectionUtils.DEFAULT_TOSTRING_SUFFIX);
    }

    /**
     * Returns a string representation of the elements of the specified iterator.
     * &lt;p&gt;
     * The string representation consists of a list of the iterable's elements,
     * enclosed in square brackets ({@code &quot;[]&quot;}). Adjacent elements are separated
     * by the characters {@code &quot;, &quot;} (a comma followed by a space). Elements are
     * converted to strings as by using the provided {@code transformer}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to convert to a string, may be null
     * @param transformer  the transformer used to get a string representation of an element
     * @return a string representation of {@code iterator}
     * @throws NullPointerException if {@code transformer} is null
     * @since 4.1
     */
    public static &lt;E&gt; String toString(final Iterator&lt;E&gt; iterator,
                                      final Transformer&lt;? super E, String&gt; transformer) {
<span class="fc" id="L1394">        return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER,</span>
                CollectionUtils.DEFAULT_TOSTRING_PREFIX, CollectionUtils.DEFAULT_TOSTRING_SUFFIX);
    }

    /**
     * Returns a string representation of the elements of the specified iterator.
     * &lt;p&gt;
     * The string representation consists of a list of the iterator's elements,
     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements
     * are separated by the provided {@code delimiter}. Elements are converted to
     * strings as by using the provided {@code transformer}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to convert to a string, may be null
     * @param transformer  the transformer used to get a string representation of an element
     * @param delimiter  the string to delimit elements
     * @param prefix  the prefix, prepended to the string representation
     * @param suffix  the suffix, appended to the string representation
     * @return a string representation of {@code iterator}
     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null
     * @since 4.1
     */
    public static &lt;E&gt; String toString(final Iterator&lt;E&gt; iterator,
                                      final Transformer&lt;? super E, String&gt; transformer,
                                      final String delimiter,
                                      final String prefix,
                                      final String suffix) {
<span class="fc" id="L1422">        Objects.requireNonNull(transformer, &quot;transformer&quot;);</span>
<span class="fc" id="L1423">        Objects.requireNonNull(delimiter, &quot;delimiter&quot;);</span>
<span class="fc" id="L1424">        Objects.requireNonNull(prefix, &quot;prefix&quot;);</span>
<span class="fc" id="L1425">        Objects.requireNonNull(suffix, &quot;suffix&quot;);</span>
<span class="fc" id="L1426">        final StringBuilder stringBuilder = new StringBuilder(prefix);</span>
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">        if (iterator != null) {</span>
<span class="fc bfc" id="L1428" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L1429">                final E element = iterator.next();</span>
<span class="fc" id="L1430">                stringBuilder.append(transformer.apply(element));</span>
<span class="fc" id="L1431">                stringBuilder.append(delimiter);</span>
<span class="fc" id="L1432">            }</span>
<span class="fc bfc" id="L1433" title="All 2 branches covered.">            if (stringBuilder.length() &gt; prefix.length()) {</span>
<span class="fc" id="L1434">                stringBuilder.setLength(stringBuilder.length() - delimiter.length());</span>
            }
        }
<span class="fc" id="L1437">        stringBuilder.append(suffix);</span>
<span class="fc" id="L1438">        return stringBuilder.toString();</span>
    }

    /**
     * Gets an iterator that transforms the elements of another iterator.
     * &lt;p&gt;
     * The transformation occurs during the next() method and the underlying
     * iterator is unaffected by the transformation.
     * &lt;/p&gt;
     *
     * @param &lt;I&gt; the input type
     * @param &lt;O&gt; the output type
     * @param iterator  the iterator to use, not null
     * @param transformer  the transform to use, not null
     * @return a new transforming iterator
     * @throws NullPointerException if either parameter is null
     */
    public static &lt;I, O&gt; Iterator&lt;O&gt; transformedIterator(final Iterator&lt;? extends I&gt; iterator,
            final Transformer&lt;? super I, ? extends O&gt; transformer) {

<span class="fc" id="L1458">        Objects.requireNonNull(iterator, &quot;iterator&quot;);</span>
<span class="fc" id="L1459">        Objects.requireNonNull(transformer, &quot;transformer&quot;);</span>
<span class="fc" id="L1460">        return new TransformIterator&lt;&gt;(iterator, transformer);</span>
    }

    /**
     * Gets an immutable version of an {@link Iterator}. The returned object
     * will always throw an {@link UnsupportedOperationException} for
     * the {@link Iterator#remove} method.
     *
     * @param &lt;E&gt; the element type
     * @param iterator  the iterator to make immutable
     * @return an immutable version of the iterator
     */
    public static &lt;E&gt; Iterator&lt;E&gt; unmodifiableIterator(final Iterator&lt;E&gt; iterator) {
<span class="fc" id="L1473">        return UnmodifiableIterator.unmodifiableIterator(iterator);</span>
    }

    /**
     * Gets an immutable version of a {@link ListIterator}. The returned object
     * will always throw an {@link UnsupportedOperationException} for
     * the {@link Iterator#remove}, {@link ListIterator#add} and
     * {@link ListIterator#set} methods.
     *
     * @param &lt;E&gt; the element type
     * @param listIterator  the iterator to make immutable
     * @return an immutable version of the iterator
     */
    public static &lt;E&gt; ListIterator&lt;E&gt; unmodifiableListIterator(final ListIterator&lt;E&gt; listIterator) {
<span class="fc" id="L1487">        return UnmodifiableListIterator.unmodifiableListIterator(listIterator);</span>
    }

    /**
     * Gets an immutable version of a {@link MapIterator}. The returned object
     * will always throw an {@link UnsupportedOperationException} for
     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.
     *
     * @param &lt;K&gt; the key type
     * @param &lt;V&gt; the value type
     * @param mapIterator  the iterator to make immutable
     * @return an immutable version of the iterator
     */
    public static &lt;K, V&gt; MapIterator&lt;K, V&gt; unmodifiableMapIterator(final MapIterator&lt;K, V&gt; mapIterator) {
<span class="fc" id="L1501">        return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);</span>
    }

    /**
     * Returns an iterator that interleaves elements from the decorated iterators.
     *
     * @param &lt;E&gt; the element type
     * @param iterators  the array of iterators to interleave
     * @return an iterator, interleaving the decorated iterators
     * @throws NullPointerException if any iterator is null
     * @since 4.1
     */
    public static &lt;E&gt; ZippingIterator&lt;E&gt; zippingIterator(final Iterator&lt;? extends E&gt;... iterators) {
<span class="fc" id="L1514">        return new ZippingIterator&lt;&gt;(iterators);</span>
    }

    /**
     * Returns an iterator that interleaves elements from the decorated iterators.
     *
     * @param &lt;E&gt; the element type
     * @param a  the first iterator to interleave
     * @param b  the second iterator to interleave
     * @return an iterator, interleaving the decorated iterators
     * @throws NullPointerException if any iterator is null
     * @since 4.1
     */
    public static &lt;E&gt; ZippingIterator&lt;E&gt; zippingIterator(final Iterator&lt;? extends E&gt; a,
                                                         final Iterator&lt;? extends E&gt; b) {
<span class="fc" id="L1529">        return new ZippingIterator&lt;&gt;(a, b);</span>
    }

    /**
     * Returns an iterator that interleaves elements from the decorated iterators.
     *
     * @param &lt;E&gt; the element type
     * @param a  the first iterator to interleave
     * @param b  the second iterator to interleave
     * @param c  the third iterator to interleave
     * @return an iterator, interleaving the decorated iterators
     * @throws NullPointerException if any iterator is null
     * @since 4.1
     */
    public static &lt;E&gt; ZippingIterator&lt;E&gt; zippingIterator(final Iterator&lt;? extends E&gt; a,
                                                         final Iterator&lt;? extends E&gt; b,
                                                         final Iterator&lt;? extends E&gt; c) {
<span class="fc" id="L1546">        return new ZippingIterator&lt;&gt;(a, b, c);</span>
    }

    /**
     * Don't allow instances.
     */
    private IteratorUtils() {
        // empty
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>