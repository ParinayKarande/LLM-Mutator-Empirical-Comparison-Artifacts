<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IterableUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Collections</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4</a> &gt; <span class="el_source">IterableUtils.java</span></div><h1>IterableUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.collections4;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import org.apache.commons.collections4.functors.EqualPredicate;
import org.apache.commons.collections4.iterators.LazyIteratorChain;
import org.apache.commons.collections4.iterators.ReverseListIterator;
import org.apache.commons.collections4.iterators.UniqueFilterIterator;

/**
 * Provides utility methods and decorators for {@link Iterable} instances.
 * &lt;p&gt;
 * &lt;strong&gt;Note&lt;/strong&gt;: This utility class has been designed with fail-fast argument checking.
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;All decorator methods are &lt;em&gt;not&lt;/em&gt; null-safe for the provided Iterable argument; for example, they will throw a {@link NullPointerException} if a
 * null Iterable is passed as argument.
 * &lt;li&gt;All other utility methods are null-safe for the provided Iterable argument; for example, they will treat a null Iterable the same way as an empty one.
 * For other arguments which are null, a {@link Predicate} will result in a {@link NullPointerException}. Exception: passing a null {@link Comparator} is
 * equivalent to a Comparator with natural ordering.
 * &lt;/ul&gt;
 *
 * @since 4.1
 */
public class IterableUtils {

    /**
     * Inner class to distinguish unmodifiable instances.
     */
    private static final class UnmodifiableIterable&lt;E&gt; extends FluentIterable&lt;E&gt; {
        private final Iterable&lt;E&gt; iterable;

<span class="fc" id="L58">        UnmodifiableIterable(final Iterable&lt;E&gt; iterable) {</span>
<span class="fc" id="L59">            this.iterable = iterable;</span>
<span class="fc" id="L60">        }</span>

        @Override
        public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L64">            return IteratorUtils.unmodifiableIterator(iterable.iterator());</span>
        }
    }

    /**
     * An empty iterable.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L72">    static final FluentIterable EMPTY_ITERABLE = new FluentIterable&lt;Object&gt;() {</span>
        @Override
        public Iterator&lt;Object&gt; iterator() {
<span class="fc" id="L75">            return IteratorUtils.emptyIterator();</span>
        }
    };

    /**
     * Returns a view of the given iterable that contains at most the given number
     * of elements.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to limit, may not be null
     * @param maxSize  the maximum number of elements, must not be negative
     * @return a bounded view on the specified iterable
     * @throws IllegalArgumentException if maxSize is negative
     * @throws NullPointerException if iterable is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; boundedIterable(final Iterable&lt;E&gt; iterable, final long maxSize) {
<span class="fc" id="L95">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (maxSize &lt; 0) {</span>
<span class="fc" id="L97">            throw new IllegalArgumentException(&quot;MaxSize parameter must not be negative.&quot;);</span>
        }

<span class="fc" id="L100">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L103">                return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);</span>
            }
        };
    }

    /**
     * Combines the provided iterables into a single iterable.
     * &lt;p&gt;
     * The returned iterable has an iterator that traverses the elements in the order
     * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators
     * are not polled until necessary.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterables  the iterables to combine, may not be null
     * @return a new iterable, combining the provided iterables
     * @throws NullPointerException if either of the provided iterables is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; chainedIterable(final Iterable&lt;? extends E&gt;... iterables) {
<span class="fc" id="L126">        checkNotNull(iterables);</span>
<span class="fc" id="L127">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L130">                return new LazyIteratorChain&lt;E&gt;() {</span>
                    @Override
                    protected Iterator&lt;? extends E&gt; nextIterator(final int count) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">                        if (count &gt; iterables.length) {</span>
<span class="fc" id="L134">                            return null;</span>
                        }
<span class="fc" id="L136">                        return iterables[count - 1].iterator();</span>
                    }
                };
            }
        };
    }

    /**
     * Combines two iterables into a single iterable.
     * &lt;p&gt;
     * The returned iterable has an iterator that traverses the elements in {@code a},
     * followed by the elements in {@code b}. The source iterators are not polled until
     * necessary.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param a  the first iterable, may not be null
     * @param b  the second iterable, may not be null
     * @return a new iterable, combining the provided iterables
     * @throws NullPointerException if either a or b is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; Iterable&lt;E&gt; chainedIterable(final Iterable&lt;? extends E&gt; a,
                                                  final Iterable&lt;? extends E&gt; b) {
<span class="fc" id="L164">        return chainedIterable(new Iterable[] {a, b});</span>
    }

    /**
     * Combines three iterables into a single iterable.
     * &lt;p&gt;
     * The returned iterable has an iterator that traverses the elements in {@code a},
     * followed by the elements in {@code b} and {@code c}. The source iterators are
     * not polled until necessary.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param a  the first iterable, may not be null
     * @param b  the second iterable, may not be null
     * @param c  the third iterable, may not be null
     * @return a new iterable, combining the provided iterables
     * @throws NullPointerException if either of the provided iterables is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; Iterable&lt;E&gt; chainedIterable(final Iterable&lt;? extends E&gt; a,
                                                  final Iterable&lt;? extends E&gt; b,
                                                  final Iterable&lt;? extends E&gt; c) {
<span class="nc" id="L190">        return chainedIterable(new Iterable[] {a, b, c});</span>
    }

    /**
     * Combines four iterables into a single iterable.
     * &lt;p&gt;
     * The returned iterable has an iterator that traverses the elements in {@code a},
     * followed by the elements in {@code b}, {@code c} and {@code d}. The source
     * iterators are not polled until necessary.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param a  the first iterable, may not be null
     * @param b  the second iterable, may not be null
     * @param c  the third iterable, may not be null
     * @param d  the fourth iterable, may not be null
     * @return a new iterable, combining the provided iterables
     * @throws NullPointerException if either of the provided iterables is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;E&gt; Iterable&lt;E&gt; chainedIterable(final Iterable&lt;? extends E&gt; a,
                                                  final Iterable&lt;? extends E&gt; b,
                                                  final Iterable&lt;? extends E&gt; c,
                                                  final Iterable&lt;? extends E&gt; d) {
<span class="nc" id="L218">        return chainedIterable(new Iterable[] {a, b, c, d});</span>
    }

    /**
     * Fail-fast check for null arguments.
     *
     * @param iterables  the iterables to check
     * @throws NullPointerException if the argument or any of its contents is null
     */
    static void checkNotNull(final Iterable&lt;?&gt;... iterables) {
<span class="fc" id="L228">        Objects.requireNonNull(iterables, &quot;iterables&quot;);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (final Iterable&lt;?&gt; iterable : iterables) {</span>
<span class="fc" id="L230">            Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
        }
<span class="fc" id="L232">    }</span>

    /**
     * Combines the two provided iterables into an ordered iterable using the
     * provided comparator. If the comparator is null, natural ordering will be
     * used.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the
     * corresponding input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param comparator  the comparator defining an ordering over the elements,
     *   may be null, in which case natural ordering will be used
     * @param a  the first iterable, may not be null
     * @param b  the second iterable, may not be null
     * @return a filtered view on the specified iterable
     * @throws NullPointerException if either of the provided iterables is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; collatedIterable(final Comparator&lt;? super E&gt; comparator,
                                                   final Iterable&lt;? extends E&gt; a,
                                                   final Iterable&lt;? extends E&gt; b) {
<span class="fc" id="L254">        checkNotNull(a, b);</span>
<span class="fc" id="L255">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L258">                return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());</span>
            }
        };
    }

    /**
     * Combines the two provided iterables into an ordered iterable using
     * natural ordering.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the
     * corresponding input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param a  the first iterable, must not be null
     * @param b  the second iterable, must not be null
     * @return a filtered view on the specified iterable
     * @throws NullPointerException if either of the provided iterables is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; collatedIterable(final Iterable&lt;? extends E&gt; a,
                                                   final Iterable&lt;? extends E&gt; b) {
<span class="fc" id="L279">        checkNotNull(a, b);</span>
<span class="fc" id="L280">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L283">                return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());</span>
            }
        };
    }

    /**
     * Checks if the object is contained in the given iterable. Object equality
     * is tested with an {@code equator} unlike {@link #contains(Iterable, Object)}
     * which uses {@link Object#equals(Object)}.
     * &lt;p&gt;
     * A {@code null} or empty iterable returns false.
     * A {@code null} object will not be passed to the equator, instead a
     * {@link org.apache.commons.collections4.functors.NullPredicate NullPredicate}
     * will be used.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterable} contains
     * @param iterable  the iterable to check, may be null
     * @param object  the object to check
     * @param equator  the equator to use to check, may not be null
     * @return true if the object is contained in the iterable, false otherwise
     * @throws NullPointerException if equator is null
     */
    public static &lt;E&gt; boolean contains(final Iterable&lt;? extends E&gt; iterable, final E object,
                                       final Equator&lt;? super E&gt; equator) {
<span class="fc" id="L308">        Objects.requireNonNull(equator, &quot;equator&quot;);</span>
<span class="fc" id="L309">        return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));</span>
    }

    /**
     * Checks if the object is contained in the given iterable.
     * &lt;p&gt;
     * A {@code null} or empty iterable returns false.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterable} contains
     * @param iterable  the iterable to check, may be null
     * @param object  the object to check
     * @return true if the object is contained in the iterable, false otherwise
     */
    public static &lt;E&gt; boolean contains(final Iterable&lt;E&gt; iterable, final Object object) {
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (iterable instanceof Collection&lt;?&gt;) {</span>
<span class="fc" id="L325">            return ((Collection&lt;E&gt;) iterable).contains(object);</span>
        }
<span class="fc" id="L327">        return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);</span>
    }

    /**
     * Counts the number of elements in the input iterable that match the predicate.
     * &lt;p&gt;
     * A {@code null} iterable matches no elements.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterable} contains
     * @param input  the {@link Iterable} to get the input from, may be null
     * @param predicate  the predicate to use, may not be null
     * @return the number of matches for the predicate in the collection
     * @throws NullPointerException if predicate is null
     */
    public static &lt;E&gt; long countMatches(final Iterable&lt;E&gt; input, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L343">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc" id="L344">        return size(filteredIterable(emptyIfNull(input), predicate));</span>
    }

    /**
     * Finds and returns the List of duplicate elements in the given collection.
     *
     * @param &lt;E&gt; the type of elements in the collection.
     * @param iterable the list to test, must not be null.
     * @return the set of duplicate elements, may be empty.
     * @since 4.5.0-M3
     */
    public static &lt;E&gt; List&lt;E&gt; duplicateList(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L356">        return new ArrayList&lt;&gt;(duplicateSequencedSet(iterable));</span>
    }

    /**
     * Finds and returns the sequenced Set of duplicate elements in the given collection.
     * &lt;p&gt;
     * Once we are on Java 21 and a new major version, the return type should be SequencedSet.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of elements in the collection.
     * @param iterable the list to test, must not be null.
     * @return the set of duplicate elements, may be empty.
     * @since 4.5.0-M3
     */
    public static &lt;E&gt; Set&lt;E&gt; duplicateSequencedSet(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L371">        return duplicateSet(iterable, new LinkedHashSet&lt;&gt;());</span>
    }

    /**
     * Finds and returns the set of duplicate elements in the given collection.
     *
     * @param &lt;E&gt; the type of elements in the collection.
     * @param iterable the list to test, must not be null.
     * @return the set of duplicate elements, may be empty.
     * @since 4.5.0-M3
     */
    public static &lt;E&gt; Set&lt;E&gt; duplicateSet(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L383">        return duplicateSet(iterable, new HashSet&lt;&gt;());</span>
    }

    /**
     * Worker method for {@link #duplicateSet(Collection)} and friends.
     *
     * @param &lt;C&gt; the type of Collection.
     * @param &lt;E&gt; the type of elements in the Collection.
     * @param iterable the list to test, must not be null.
     * @param duplicates the list to test, must not be null.
     * @return the set of duplicate elements, may be empty.
     */
    static &lt;C extends Collection&lt;E&gt;, E&gt; C duplicateSet(final Iterable&lt;E&gt; iterable, final C duplicates) {
<span class="fc" id="L396">        final Set&lt;E&gt; set = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">        for (final E e : iterable) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            (set.contains(e) ? duplicates : set).add(e);</span>
<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">        return duplicates;</span>
    }

    /**
     * Returns an immutable empty iterable if the argument is null,
     * or the argument itself otherwise.
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable, may be null
     * @return an empty iterable if the argument is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; emptyIfNull(final Iterable&lt;E&gt; iterable) {
<span class="fc bfc" id="L412" title="All 2 branches covered.">        return iterable == null ? IterableUtils.&lt;E&gt;emptyIterable() : iterable;</span>
    }

    /**
     * Gets an empty iterable.
     * &lt;p&gt;
     * This iterable does not contain any elements.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @return an empty iterable
     */
    @SuppressWarnings(&quot;unchecked&quot;) // OK, empty collection is compatible with any type
    public static &lt;E&gt; Iterable&lt;E&gt; emptyIterable() {
<span class="fc" id="L426">        return EMPTY_ITERABLE;</span>
    }

    /**
     * Returns an empty iterator if the argument is {@code null},
     * or {@code iterable.iterator()} otherwise.
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable, possibly {@code null}
     * @return an empty iterator if the argument is {@code null}
     */
    private static &lt;E&gt; Iterator&lt;E&gt; emptyIteratorIfNull(final Iterable&lt;E&gt; iterable) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">        return iterable != null ? iterable.iterator() : IteratorUtils.&lt;E&gt;emptyIterator();</span>
    }

    /**
     * Returns a view of the given iterable that only contains elements matching
     * the provided predicate.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the
     * corresponding input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to filter, may not be null
     * @param predicate  the predicate used to filter elements, may not be null
     * @return a filtered view on the specified iterable
     * @throws NullPointerException if either iterable or predicate is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; filteredIterable(final Iterable&lt;E&gt; iterable,
                                                   final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L457">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc" id="L458">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc" id="L459">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L462">                return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);</span>
            }
        };
    }

    /**
     * Finds the first element in the given iterable which matches the given predicate.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns null.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to search, may be null
     * @param predicate  the predicate to use, must not be null
     * @return the first element of the iterable which matches the predicate or null if none could be found
     * @throws NullPointerException if predicate is null
     */
    public static &lt;E&gt; E find(final Iterable&lt;E&gt; iterable, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L480">        return IteratorUtils.find(emptyIteratorIfNull(iterable), predicate);</span>
    }

    /**
     * Shortcut for {@code get(iterator, 0)}.
     * &lt;p&gt;
     * Returns the {@code first} value in the {@code iterable}'s {@link Iterator}, throwing
     * {@code IndexOutOfBoundsException} if there is no such element.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the type of object in the {@link Iterable}.
     * @param iterable  the {@link Iterable} to get a value from, may be null
     * @return the first object
     * @throws IndexOutOfBoundsException if the request is invalid
     * @since 4.2
     */
    public static &lt;T&gt; T first(final Iterable&lt;T&gt; iterable) {
<span class="nc" id="L500">        return get(iterable, 0);</span>
    }

    /**
     * Applies the closure to each element of the provided iterable.
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterator to use, may be null
     * @param closure  the closure to apply to each element, may not be null
     * @throws NullPointerException if closure is null
     */
    public static &lt;E&gt; void forEach(final Iterable&lt;E&gt; iterable, final Closure&lt;? super E&gt; closure) {
<span class="fc" id="L512">        IteratorUtils.forEach(emptyIteratorIfNull(iterable), closure);</span>
<span class="fc" id="L513">    }</span>

    /**
     * Executes the given closure on each but the last element in the iterable.
     * &lt;p&gt;
     * If the input iterable is null no change is made.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterable} contains
     * @param iterable  the iterable to get the input from, may be null
     * @param closure  the closure to perform, may not be null
     * @return the last element in the iterable, or null if iterable is null or empty
     */
    public static &lt;E&gt; E forEachButLast(final Iterable&lt;E&gt; iterable, final Closure&lt;? super E&gt; closure) {
<span class="fc" id="L527">        return IteratorUtils.forEachButLast(emptyIteratorIfNull(iterable), closure);</span>
    }

    /**
     * Returns the number of occurrences of the provided object in the iterable.
     *
     * @param &lt;E&gt; the element type that the {@link Iterable} may contain
     * @param &lt;T&gt; the element type of the object to find
     * @param iterable  the {@link Iterable} to search
     * @param obj  the object to find the cardinality of
     * @return the number of occurrences of obj in iterable
     */
    public static &lt;E, T extends E&gt; int frequency(final Iterable&lt;E&gt; iterable, final T obj) {
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (iterable instanceof Set&lt;?&gt;) {</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">            return ((Set&lt;E&gt;) iterable).contains(obj) ? 1 : 0;</span>
        }
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (iterable instanceof Bag&lt;?&gt;) {</span>
<span class="fc" id="L544">            return ((Bag&lt;E&gt;) iterable).getCount(obj);</span>
        }
<span class="fc" id="L546">        return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.&lt;E&gt;equalPredicate(obj)));</span>
    }

    /**
     * Returns the {@code index}-th value in the {@code iterable}'s {@link Iterator}, throwing
     * {@code IndexOutOfBoundsException} if there is no such element.
     * &lt;p&gt;
     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the type of object in the {@link Iterable}.
     * @param iterable  the {@link Iterable} to get a value from, may be null
     * @param index  the index to get
     * @return the object at the specified index
     * @throws IndexOutOfBoundsException if the index is invalid
     */
    public static &lt;T&gt; T get(final Iterable&lt;T&gt; iterable, final int index) {
<span class="fc" id="L563">        CollectionUtils.checkIndexBounds(index);</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">        if (iterable instanceof List&lt;?&gt;) {</span>
<span class="fc" id="L565">            return ((List&lt;T&gt;) iterable).get(index);</span>
        }
<span class="fc" id="L567">        return IteratorUtils.get(emptyIteratorIfNull(iterable), index);</span>
    }

    /**
     * Returns the index of the first element in the specified iterable that
     * matches the given predicate.
     * &lt;p&gt;
     * A {@code null} or empty iterable returns -1.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to search, may be null
     * @param predicate  the predicate to use, must not be null
     * @return the index of the first element which matches the predicate or -1 if none matches
     * @throws NullPointerException if predicate is null
     */
    public static &lt;E&gt; int indexOf(final Iterable&lt;E&gt; iterable, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L584">        return IteratorUtils.indexOf(emptyIteratorIfNull(iterable), predicate);</span>
    }

    /**
     * Answers true if the provided iterable is empty.
     * &lt;p&gt;
     * A {@code null} iterable returns true.
     * &lt;/p&gt;
     *
     * @param iterable  the {@link Iterable to use}, may be null
     * @return true if the iterable is null or empty, false otherwise
     */
    public static boolean isEmpty(final Iterable&lt;?&gt; iterable) {
<span class="fc bfc" id="L597" title="All 2 branches covered.">        if (iterable instanceof Collection&lt;?&gt;) {</span>
<span class="fc" id="L598">            return ((Collection&lt;?&gt;) iterable).isEmpty();</span>
        }
<span class="fc" id="L600">        return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));</span>
    }

    /**
     * Returns a view of the given iterable which will cycle infinitely over
     * its elements.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} if
     * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent
     * cycles omit the removed element, which is no longer in {@code iterable}. The
     * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}
     * is empty.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to loop, may not be null
     * @return a view of the iterable, providing an infinite loop over its elements
     * @throws NullPointerException if iterable is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; loopingIterable(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L620">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc" id="L621">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L624">                return new LazyIteratorChain&lt;E&gt;() {</span>
                    @Override
                    protected Iterator&lt;? extends E&gt; nextIterator(final int count) {
<span class="fc bfc" id="L627" title="All 2 branches covered.">                        if (IterableUtils.isEmpty(iterable)) {</span>
<span class="fc" id="L628">                            return null;</span>
                        }
<span class="fc" id="L630">                        return iterable.iterator();</span>
                    }
                };
            }
        };
    }

    /**
     * Answers true if a predicate is true for every element of an iterable.
     * &lt;p&gt;
     * A {@code null} or empty iterable returns true.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterable} contains
     * @param iterable  the {@link Iterable} to use, may be null
     * @param predicate  the predicate to use, may not be null
     * @return true if every element of the collection matches the predicate or if the
     *   collection is empty, false otherwise
     * @throws NullPointerException if predicate is null
     */
    public static &lt;E&gt; boolean matchesAll(final Iterable&lt;E&gt; iterable, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L651">        return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);</span>
    }

    /**
     * Answers true if a predicate is true for any element of the iterable.
     * &lt;p&gt;
     * A {@code null} or empty iterable returns false.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the type of object the {@link Iterable} contains
     * @param iterable  the {@link Iterable} to use, may be null
     * @param predicate  the predicate to use, may not be null
     * @return true if any element of the collection matches the predicate, false otherwise
     * @throws NullPointerException if predicate is null
     */
    public static &lt;E&gt; boolean matchesAny(final Iterable&lt;E&gt; iterable, final Predicate&lt;? super E&gt; predicate) {
<span class="fc" id="L667">        return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);</span>
    }

    /**
     * Partitions all elements from iterable into separate output collections,
     * based on the evaluation of the given predicates.
     * &lt;p&gt;
     * For each predicate, the returned list will contain a collection holding
     * all elements of the input iterable matching the predicate. The last collection
     * contained in the list will hold all elements which didn't match any predicate:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  [C1, C2, R] = partition(I, P1, P2) with
     *  I = input
     *  P1 = first predicate
     *  P2 = second predicate
     *  C1 = collection of elements matching P1
     *  C2 = collection of elements matching P2
     *  R = collection of elements rejected by all predicates
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note&lt;/strong&gt;: elements are only added to the output collection of the first matching
     * predicate, determined by the order of arguments.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the input iterable is {@code null}, the same is returned as for an
     * empty iterable.
     * If no predicates have been provided, all elements of the input collection
     * will be added to the rejected collection.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &amp;lt; 3]
     * and [x &amp;lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].
     * &lt;/p&gt;
     *
     * @param &lt;O&gt;  the type of object the {@link Iterable} contains
     * @param &lt;R&gt;  the type of the output {@link Collection}
     * @param iterable  the collection to get the input from, may be null
     * @param partitionFactory  the factory used to create the output collections
     * @param predicates  the predicates to use, may not be null
     * @return a list containing the output collections
     * @throws NullPointerException if any predicate is null
     */
    public static &lt;O, R extends Collection&lt;O&gt;&gt; List&lt;R&gt; partition(final Iterable&lt;? extends O&gt; iterable,
            final Factory&lt;R&gt; partitionFactory, final Predicate&lt;? super O&gt;... predicates) {

<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (iterable == null) {</span>
<span class="fc" id="L714">            final Iterable&lt;O&gt; empty = emptyIterable();</span>
<span class="fc" id="L715">            return partition(empty, partitionFactory, predicates);</span>
        }

<span class="fc" id="L718">        Objects.requireNonNull(predicates, &quot;predicates&quot;);</span>

<span class="fc bfc" id="L720" title="All 2 branches covered.">        for (final Predicate&lt;?&gt; predicate : predicates) {</span>
<span class="fc" id="L721">            Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>
        }

<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (predicates.length &lt; 1) {</span>
            // return the entire input collection as a single partition
<span class="fc" id="L726">            final R singlePartition = partitionFactory.get();</span>
<span class="fc" id="L727">            CollectionUtils.addAll(singlePartition, iterable);</span>
<span class="fc" id="L728">            return Collections.singletonList(singlePartition);</span>
        }

        // create the empty partitions
<span class="fc" id="L732">        final int numberOfPredicates = predicates.length;</span>
<span class="fc" id="L733">        final int numberOfPartitions = numberOfPredicates + 1;</span>
<span class="fc" id="L734">        final List&lt;R&gt; partitions = new ArrayList&lt;&gt;(numberOfPartitions);</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">        for (int i = 0; i &lt; numberOfPartitions; ++i) {</span>
<span class="fc" id="L736">            partitions.add(partitionFactory.get());</span>
        }

        // for each element in inputCollection:
        // find the first predicate that evaluates to true.
        // if there is a predicate, add the element to the corresponding partition.
        // if there is no predicate, add it to the last, catch-all partition.
<span class="fc bfc" id="L743" title="All 2 branches covered.">        for (final O element : iterable) {</span>
<span class="fc" id="L744">            boolean elementAssigned = false;</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">            for (int i = 0; i &lt; numberOfPredicates; ++i) {</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">                if (predicates[i].test(element)) {</span>
<span class="fc" id="L747">                    partitions.get(i).add(element);</span>
<span class="fc" id="L748">                    elementAssigned = true;</span>
<span class="fc" id="L749">                    break;</span>
                }
            }

<span class="fc bfc" id="L753" title="All 2 branches covered.">            if (!elementAssigned) {</span>
                // no predicates evaluated to true
                // add element to last partition
<span class="fc" id="L756">                partitions.get(numberOfPredicates).add(element);</span>
            }
<span class="fc" id="L758">        }</span>

<span class="fc" id="L760">        return partitions;</span>
    }

    /**
     * Partitions all elements from iterable into separate output collections,
     * based on the evaluation of the given predicate.
     * &lt;p&gt;
     * For each predicate, the result will contain a list holding all elements of the
     * input iterable matching the predicate. The last list will hold all elements
     * which didn't match any predicate:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  [C1, R] = partition(I, P1) with
     *  I = input
     *  P1 = first predicate
     *  C1 = collection of elements matching P1
     *  R = collection of elements rejected by all predicates
     * &lt;/pre&gt;
     * &lt;p&gt;
     * If the input iterable is {@code null}, the same is returned as for an
     * empty iterable.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Example: for an input list [1, 2, 3, 4, 5] calling partition with a predicate [x &amp;lt; 3]
     * will result in the following output: [[1, 2], [3, 4, 5]].
     * &lt;/p&gt;
     *
     * @param &lt;O&gt;  the type of object the {@link Iterable} contains
     * @param iterable  the iterable to partition, may be null
     * @param predicate  the predicate to use, may not be null
     * @return a list containing the output collections
     * @throws NullPointerException if predicate is null
     */
    public static &lt;O&gt; List&lt;List&lt;O&gt;&gt; partition(final Iterable&lt;? extends O&gt; iterable,
                                              final Predicate&lt;? super O&gt; predicate) {
<span class="fc" id="L795">        Objects.requireNonNull(predicate, &quot;predicate&quot;);</span>
        @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) // safe
<span class="fc" id="L797">        final Factory&lt;List&lt;O&gt;&gt; factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);</span>
        @SuppressWarnings(&quot;unchecked&quot;) // safe
<span class="fc" id="L799">        final Predicate&lt;? super O&gt;[] predicates = new Predicate[] { predicate };</span>
<span class="fc" id="L800">        return partition(iterable, factory, predicates);</span>
    }

    /**
     * Partitions all elements from iterable into separate output collections,
     * based on the evaluation of the given predicates.
     * &lt;p&gt;
     * For each predicate, the result will contain a list holding all elements of the
     * input iterable matching the predicate. The last list will hold all elements
     * which didn't match any predicate:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  [C1, C2, R] = partition(I, P1, P2) with
     *  I = input
     *  P1 = first predicate
     *  P2 = second predicate
     *  C1 = collection of elements matching P1
     *  C2 = collection of elements matching P2
     *  R = collection of elements rejected by all predicates
     * &lt;/pre&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note&lt;/strong&gt;: elements are only added to the output collection of the first matching
     * predicate, determined by the order of arguments.
     * &lt;/p&gt;
     * &lt;p&gt;
     * If the input iterable is {@code null}, the same is returned as for an
     * empty iterable.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &amp;lt; 3]
     * and [x &amp;lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].
     * &lt;/p&gt;
     *
     * @param &lt;O&gt;  the type of object the {@link Iterable} contains
     * @param iterable  the collection to get the input from, may be null
     * @param predicates  the predicates to use, may not be null
     * @return a list containing the output collections
     * @throws NullPointerException if any predicate is null
     */
    public static &lt;O&gt; List&lt;List&lt;O&gt;&gt; partition(final Iterable&lt;? extends O&gt; iterable,
                                              final Predicate&lt;? super O&gt;... predicates) {

        @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) // safe
<span class="fc" id="L843">        final Factory&lt;List&lt;O&gt;&gt; factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);</span>
<span class="fc" id="L844">        return partition(iterable, factory, predicates);</span>
    }

    /**
     * Returns a reversed view of the given iterable.
     * &lt;p&gt;
     * In case the provided iterable is a {@link List} instance, a
     * {@link ReverseListIterator} will be used to reverse the traversal
     * order, otherwise an intermediate {@link List} needs to be created.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} if the
     * provided iterable is a {@link List} instance.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to use, may not be null
     * @return a reversed view of the specified iterable
     * @throws NullPointerException if iterable is null
     * @see ReverseListIterator
     */
    public static &lt;E&gt; Iterable&lt;E&gt; reversedIterable(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L866">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc" id="L867">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">                final List&lt;E&gt; list = iterable instanceof List&lt;?&gt; ?</span>
<span class="fc" id="L871">                        (List&lt;E&gt;) iterable :</span>
<span class="pc" id="L872">                        IteratorUtils.toList(iterable.iterator());</span>
<span class="fc" id="L873">                return new ReverseListIterator&lt;&gt;(list);</span>
            }
        };
    }

    /**
     * Returns the number of elements contained in the given iterator.
     * &lt;p&gt;
     * A {@code null} or empty iterator returns {@code 0}.
     * &lt;/p&gt;
     *
     * @param iterable  the iterable to check, may be null
     * @return the number of elements contained in the iterable
     */
    public static int size(final Iterable&lt;?&gt; iterable) {
<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (iterable == null) {</span>
<span class="fc" id="L889">            return 0;</span>
        }
<span class="fc bfc" id="L891" title="All 2 branches covered.">        if (iterable instanceof Collection&lt;?&gt;) {</span>
<span class="fc" id="L892">            return ((Collection&lt;?&gt;) iterable).size();</span>
        }
<span class="fc" id="L894">        return IteratorUtils.size(emptyIteratorIfNull(iterable));</span>
    }

    /**
     * Returns a view of the given iterable that skips the first N elements.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to use, may not be null
     * @param elementsToSkip  the number of elements to skip from the start, must not be negative
     * @return a view of the specified iterable, skipping the first N elements
     * @throws IllegalArgumentException if elementsToSkip is negative
     * @throws NullPointerException if iterable is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; skippingIterable(final Iterable&lt;E&gt; iterable, final long elementsToSkip) {
<span class="fc" id="L912">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">        if (elementsToSkip &lt; 0) {</span>
<span class="fc" id="L914">            throw new IllegalArgumentException(&quot;ElementsToSkip parameter must not be negative.&quot;);</span>
        }

<span class="fc" id="L917">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L920">                return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);</span>
            }
        };
    }

    /**
     * Gets a new list with the contents of the provided iterable.
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to use, may be null
     * @return a list of the iterator contents
     */
    public static &lt;E&gt; List&lt;E&gt; toList(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L933">        return IteratorUtils.toList(emptyIteratorIfNull(iterable));</span>
    }

    /**
     * Returns a string representation of the elements of the specified iterable.
     * &lt;p&gt;
     * The string representation consists of a list of the iterable's elements,
     * enclosed in square brackets ({@code &quot;[]&quot;}). Adjacent elements are separated
     * by the characters {@code &quot;, &quot;} (a comma followed by a space). Elements are
     * converted to strings as by {@code String.valueOf(Object)}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to convert to a string, may be null
     * @return a string representation of {@code iterable}
     */
    public static &lt;E&gt; String toString(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L950">        return IteratorUtils.toString(emptyIteratorIfNull(iterable));</span>
    }

    /**
     * Returns a string representation of the elements of the specified iterable.
     * &lt;p&gt;
     * The string representation consists of a list of the iterable's elements,
     * enclosed in square brackets ({@code &quot;[]&quot;}). Adjacent elements are separated
     * by the characters {@code &quot;, &quot;} (a comma followed by a space). Elements are
     * converted to strings as by using the provided {@code transformer}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to convert to a string, may be null
     * @param transformer  the transformer used to get a string representation of an element
     * @return a string representation of {@code iterable}
     * @throws NullPointerException if {@code transformer} is null
     */
    public static &lt;E&gt; String toString(final Iterable&lt;E&gt; iterable,
                                      final Transformer&lt;? super E, String&gt; transformer) {
<span class="fc" id="L970">        Objects.requireNonNull(transformer, &quot;transformer&quot;);</span>
<span class="fc" id="L971">        return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);</span>
    }

    /**
     * Returns a string representation of the elements of the specified iterable.
     * &lt;p&gt;
     * The string representation consists of a list of the iterable's elements,
     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements
     * are separated by the provided {@code delimiter}. Elements are converted to
     * strings as by using the provided {@code transformer}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to convert to a string, may be null
     * @param transformer  the transformer used to get a string representation of an element
     * @param delimiter  the string to delimit elements
     * @param prefix  the prefix, prepended to the string representation
     * @param suffix  the suffix, appended to the string representation
     * @return a string representation of {@code iterable}
     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null
     */
    public static &lt;E&gt; String toString(final Iterable&lt;E&gt; iterable,
                                      final Transformer&lt;? super E, String&gt; transformer,
                                      final String delimiter,
                                      final String prefix,
                                      final String suffix) {
<span class="fc" id="L997">        return IteratorUtils.toString(emptyIteratorIfNull(iterable),</span>
                                      transformer, delimiter, prefix, suffix);
    }

    /**
     * Returns a transformed view of the given iterable where all of its elements
     * have been transformed by the provided transformer.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;I&gt;  the input element type
     * @param &lt;O&gt;  the output element type
     * @param iterable  the iterable to transform, may not be null
     * @param transformer  the transformer, must not be null
     * @return a transformed view of the specified iterable
     * @throws NullPointerException if either iterable or transformer is null
     */
    public static &lt;I, O&gt; Iterable&lt;O&gt; transformedIterable(final Iterable&lt;I&gt; iterable,
                                                         final Transformer&lt;? super I, ? extends O&gt; transformer) {
<span class="fc" id="L1018">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc" id="L1019">        Objects.requireNonNull(transformer, &quot;transformer&quot;);</span>
<span class="fc" id="L1020">        return new FluentIterable&lt;O&gt;() {</span>
            @Override
            public Iterator&lt;O&gt; iterator() {
<span class="fc" id="L1023">                return IteratorUtils.transformedIterator(iterable.iterator(), transformer);</span>
            }
        };
    }

    /**
     * Returns a unique view of the given iterable.
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the
     * corresponding input iterator supports it. Calling {@code remove()}
     * will only remove a single element from the underlying iterator.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to use, may not be null
     * @return a unique view of the specified iterable
     * @throws NullPointerException if iterable is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; uniqueIterable(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L1042">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc" id="L1043">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L1046">                return new UniqueFilterIterator&lt;&gt;(iterable.iterator());</span>
            }
        };
    }

    /**
     * Returns an unmodifiable view of the given iterable.
     * &lt;p&gt;
     * The returned iterable's iterator does not support {@code remove()}.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param iterable  the iterable to use, may not be null
     * @return an unmodifiable view of the specified iterable
     * @throws NullPointerException if iterable is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; unmodifiableIterable(final Iterable&lt;E&gt; iterable) {
<span class="fc" id="L1063">        Objects.requireNonNull(iterable, &quot;iterable&quot;);</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">        if (iterable instanceof UnmodifiableIterable&lt;?&gt;) {</span>
<span class="fc" id="L1065">            return iterable;</span>
        }
<span class="fc" id="L1067">        return new UnmodifiableIterable&lt;&gt;(iterable);</span>
    }

    /**
     * Interleaves two iterables into a single iterable.
     * &lt;p&gt;
     * The returned iterable has an iterator that traverses the elements in {@code a}
     * and {@code b} in alternating order. The source iterators are not polled until
     * necessary.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding
     * input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt; the element type
     * @param a  the first iterable, may not be null
     * @param b  the second iterable, may not be null
     * @return a new iterable, interleaving the provided iterables
     * @throws NullPointerException if either a or b is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; zippingIterable(final Iterable&lt;? extends E&gt; a,
                                                  final Iterable&lt;? extends E&gt; b) {
<span class="fc" id="L1090">        Objects.requireNonNull(a, &quot;iterable&quot;);</span>
<span class="fc" id="L1091">        Objects.requireNonNull(b, &quot;iterable&quot;);</span>
<span class="fc" id="L1092">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L1095">                return IteratorUtils.zippingIterator(a.iterator(), b.iterator());</span>
            }
        };
    }

    /**
     * Interleaves two iterables into a single iterable.
     * &lt;p&gt;
     * The returned iterable has an iterator that traverses the elements in {@code a} and {@code b} in alternating order. The source iterators are not polled
     * until necessary.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The returned iterable's iterator supports {@code remove()} when the corresponding input iterator supports it.
     * &lt;/p&gt;
     *
     * @param &lt;E&gt;    the element type
     * @param first  the first iterable, may not be null
     * @param others the array of iterables to interleave, may not be null
     * @return a new iterable, interleaving the provided iterables
     * @throws NullPointerException if either of the provided iterables is null
     */
    public static &lt;E&gt; Iterable&lt;E&gt; zippingIterable(final Iterable&lt;? extends E&gt; first, final Iterable&lt;? extends E&gt;... others) {
<span class="fc" id="L1117">        Objects.requireNonNull(first, &quot;iterable&quot;);</span>
<span class="fc" id="L1118">        checkNotNull(others);</span>
<span class="fc" id="L1119">        return new FluentIterable&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
                @SuppressWarnings(&quot;unchecked&quot;) // safe
<span class="fc" id="L1123">                final Iterator&lt;? extends E&gt;[] iterators = new Iterator[others.length + 1];</span>
<span class="fc" id="L1124">                iterators[0] = first.iterator();</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">                for (int i = 0; i &lt; others.length; i++) {</span>
<span class="fc" id="L1126">                    iterators[i + 1] = others[i].iterator();</span>
                }
<span class="fc" id="L1128">                return IteratorUtils.zippingIterator(iterators);</span>
            }
        };
    }

    /**
     * Make private in 5.0.
     *
     * @deprecated TODO Make private in 5.0.
     */
    @Deprecated
<span class="nc" id="L1139">    public IterableUtils() {</span>
        // empty
<span class="nc" id="L1141">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>