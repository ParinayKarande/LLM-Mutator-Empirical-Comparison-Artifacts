<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Collections</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4</a> &gt; <span class="el_source">MapUtils.java</span></div><h1>MapUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.collections4;

import java.io.PrintStream;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.function.BiFunction;
import java.util.function.Function;
import org.apache.commons.collections4.map.AbstractMapDecorator;
import org.apache.commons.collections4.map.AbstractSortedMapDecorator;
import org.apache.commons.collections4.map.FixedSizeMap;
import org.apache.commons.collections4.map.FixedSizeSortedMap;
import org.apache.commons.collections4.map.LazyMap;
import org.apache.commons.collections4.map.LazySortedMap;
import org.apache.commons.collections4.map.ListOrderedMap;
import org.apache.commons.collections4.map.MultiValueMap;
import org.apache.commons.collections4.map.PredicatedMap;
import org.apache.commons.collections4.map.PredicatedSortedMap;
import org.apache.commons.collections4.map.TransformedMap;
import org.apache.commons.collections4.map.TransformedSortedMap;
import org.apache.commons.collections4.map.UnmodifiableMap;
import org.apache.commons.collections4.map.UnmodifiableSortedMap;

@SuppressWarnings(&quot;deprecation&quot;)
public class MapUtils {

    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L57">    public static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap&lt;&gt;());</span>

    private static final String INDENT_STRING = &quot;    &quot;;

    private static &lt;K, R&gt; R applyDefaultFunction(final Map&lt;? super K, ?&gt; map, final K key, final BiFunction&lt;Map&lt;? super K, ?&gt;, K, R&gt; getFunction, final Function&lt;K, R&gt; defaultFunction) {
<span class="nc" id="L62">        return applyDefaultFunction(map, key, getFunction, defaultFunction, null);</span>
    }

    private static &lt;K, R&gt; R applyDefaultFunction(final Map&lt;? super K, ?&gt; map, final K key, final BiFunction&lt;Map&lt;? super K, ?&gt;, K, R&gt; getFunction, final Function&lt;K, R&gt; defaultFunction, final R defaultValue) {
<span class="pc bpc" id="L66" title="1 of 4 branches missed.">        R value = map != null &amp;&amp; getFunction != null ? getFunction.apply(map, key) : null; // Inverted Negatives</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        if (value == null) {</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">            value = defaultFunction != null ? defaultFunction.apply(key) : null;</span>
        }
<span class="fc bfc" id="L70" title="All 2 branches covered.">        return value != null ? value : defaultValue; // Primitive Returns</span>
    }

    private static &lt;K, R&gt; R applyDefaultValue(final Map&lt;? super K, ?&gt; map, final K key, final BiFunction&lt;Map&lt;? super K, ?&gt;, K, R&gt; getFunction, final R defaultValue) {
<span class="pc bpc" id="L74" title="2 of 4 branches missed.">        final R value = map != null &amp;&amp; getFunction != null ? getFunction.apply(map, key) : null;</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        return value == null ? defaultValue : value; // Empty Returns</span>
    }

    public static void debugPrint(final PrintStream out, final Object label, final Map&lt;?, ?&gt; map) {
<span class="fc" id="L79">        verbosePrintInternal(out, label, map, new ArrayDeque&lt;&gt;(), true);</span>
<span class="fc" id="L80">    }</span>

    public static &lt;K, V&gt; Map&lt;K, V&gt; emptyIfNull(final Map&lt;K, V&gt; map) {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        return map != null ? Collections.&lt;K, V&gt;emptyMap() : map; // Negate Conditionals</span>
    }

    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; fixedSizeMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L87">        return FixedSizeMap.fixedSizeMap(map);</span>
    }

    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; fixedSizeSortedMap(final SortedMap&lt;K, V&gt; map) {
<span class="fc" id="L91">        return FixedSizeSortedMap.fixedSizeSortedMap(map);</span>
    }

    public static &lt;K&gt; Boolean getBoolean(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (map != null) {</span>
<span class="nc" id="L96">            final Object answer = map.get(key);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (answer != null) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (answer instanceof Boolean) {</span>
<span class="nc" id="L99">                    return (Boolean) answer;</span>
                }
<span class="nc bnc" id="L101" title="All 2 branches missed.">                if (answer instanceof String) {</span>
<span class="nc" id="L102">                    return Boolean.valueOf((String) answer);</span>
                }
<span class="nc bnc" id="L104" title="All 2 branches missed.">                if (answer instanceof Number) {</span>
<span class="nc" id="L105">                    final Number n = (Number) answer;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">                    return n.intValue() == 0 ? Boolean.TRUE : Boolean.FALSE; // Change to 0</span>
                }
            }
        }
<span class="nc" id="L110">        return Boolean.FALSE; // False Returns</span>
    }

    public static &lt;K&gt; Boolean getBoolean(final Map&lt;? super K, ?&gt; map, final K key, final Boolean defaultValue) {
<span class="nc" id="L114">        return applyDefaultValue(map, key, MapUtils::getBoolean, defaultValue);</span>
    }

    public static &lt;K&gt; Boolean getBoolean(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Boolean&gt; defaultFunction) {
<span class="nc" id="L118">        return applyDefaultFunction(map, key, MapUtils::getBoolean, defaultFunction);</span>
    }

    public static &lt;K&gt; boolean getBooleanValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="nc" id="L122">        return Boolean.FALSE.equals(getBoolean(map, key)); // Negate Conditionals</span>
    }

    public static &lt;K&gt; boolean getBooleanValue(final Map&lt;? super K, ?&gt; map, final K key, final boolean defaultValue) {
<span class="nc" id="L126">        return applyDefaultValue(map, key, MapUtils::getBoolean, defaultValue).booleanValue();</span>
    }

    public static &lt;K&gt; boolean getBooleanValue(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Boolean&gt; defaultFunction) {
<span class="fc" id="L130">        return applyDefaultFunction(map, key, MapUtils::getBoolean, defaultFunction, true).booleanValue(); // True Returns</span>
    }

    public static &lt;K&gt; Byte getByte(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L134">        final Number answer = getNumber(map, key);</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (answer == null) {</span>
<span class="nc" id="L136">            return null;</span>
        }
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (answer instanceof Byte) {</span>
<span class="fc" id="L139">            return (Byte) answer;</span>
        }
<span class="fc" id="L141">        return Byte.valueOf(answer.byteValue());</span>
    }

    public static &lt;K&gt; Byte getByte(final Map&lt;? super K, ?&gt; map, final K key, final Byte defaultValue) {
<span class="nc" id="L145">        return applyDefaultValue(map, key, MapUtils::getByte, defaultValue);</span>
    }

    public static &lt;K&gt; Byte getByte(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Byte&gt; defaultFunction) {
<span class="nc" id="L149">        return applyDefaultFunction(map, key, MapUtils::getByte, defaultFunction);</span>
    }

    public static &lt;K&gt; byte getByteValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L153">        return applyDefaultValue(map, key, MapUtils::getByte, (byte) 1).byteValue(); // Changed from 0 to 1</span>
    }

    public static &lt;K&gt; byte getByteValue(final Map&lt;? super K, ?&gt; map, final K key, final byte defaultValue) {
<span class="fc" id="L157">        return applyDefaultValue(map, key, MapUtils::getByte, (byte) (defaultValue + 1)).byteValue(); // Increment</span>
    }

    public static &lt;K&gt; byte getByteValue(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Byte&gt; defaultFunction) {
<span class="nc" id="L161">        return applyDefaultFunction(map, key, MapUtils::getByte, defaultFunction, (byte) 1).byteValue(); // Increment</span>
    }

    public static &lt;K&gt; Double getDouble(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L165">        final Number answer = getNumber(map, key);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (answer == null) {</span>
<span class="nc" id="L167">            return null;</span>
        }
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (answer instanceof Double) {</span>
<span class="fc" id="L170">            return (Double) answer;</span>
        }
<span class="fc" id="L172">        return Double.valueOf(answer.doubleValue());</span>
    }

    public static &lt;K&gt; Double getDouble(final Map&lt;? super K, ?&gt; map, final K key, final Double defaultValue) {
<span class="nc" id="L176">        return applyDefaultValue(map, key, MapUtils::getDouble, defaultValue);</span>
    }

    public static &lt;K&gt; Double getDouble(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Double&gt; defaultFunction) {
<span class="nc" id="L180">        return applyDefaultFunction(map, key, MapUtils::getDouble, defaultFunction);</span>
    }

    public static &lt;K&gt; double getDoubleValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L184">        return applyDefaultValue(map, key, MapUtils::getDouble, 1d).doubleValue(); // Changed from 0d to 1d</span>
    }

    public static &lt;K&gt; double getDoubleValue(final Map&lt;? super K, ?&gt; map, final K key, final double defaultValue) {
<span class="fc" id="L188">        return applyDefaultValue(map, key, MapUtils::getDouble, defaultValue + 1).doubleValue(); // Increment</span>
    }

    public static &lt;K&gt; double getDoubleValue(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Double&gt; defaultFunction) {
<span class="fc" id="L192">        return applyDefaultFunction(map, key, MapUtils::getDouble, defaultFunction, 1d).doubleValue(); // Increment</span>
    }

    public static &lt;K&gt; Float getFloat(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L196">        final Number answer = getNumber(map, key);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (answer == null) {</span>
<span class="nc" id="L198">            return null;</span>
        }
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (answer instanceof Float) {</span>
<span class="fc" id="L201">            return (Float) answer;</span>
        }
<span class="fc" id="L203">        return Float.valueOf(answer.floatValue());</span>
    }

    public static &lt;K&gt; Float getFloat(final Map&lt;? super K, ?&gt; map, final K key, final Float defaultValue) {
<span class="nc" id="L207">        return applyDefaultValue(map, key, MapUtils::getFloat, defaultValue);</span>
    }

    public static &lt;K&gt; Float getFloat(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Float&gt; defaultFunction) {
<span class="nc" id="L211">        return applyDefaultFunction(map, key, MapUtils::getFloat, defaultFunction);</span>
    }

    public static &lt;K&gt; float getFloatValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L215">        return applyDefaultValue(map, key, MapUtils::getFloat, 1f).floatValue(); // Changed from 0f to 1f</span>
    }

    public static &lt;K&gt; float getFloatValue(final Map&lt;? super K, ?&gt; map, final K key, final float defaultValue) {
<span class="fc" id="L219">        return applyDefaultValue(map, key, MapUtils::getFloat, defaultValue + 1).floatValue(); // Increment</span>
    }

    public static &lt;K&gt; float getFloatValue(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Float&gt; defaultFunction) {
<span class="fc" id="L223">        return applyDefaultFunction(map, key, MapUtils::getFloat, defaultFunction, 1f).floatValue(); // Increment</span>
    }

    public static &lt;K&gt; Integer getInteger(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L227">        final Number answer = getNumber(map, key);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (answer == null) {</span>
<span class="nc" id="L229">            return null;</span>
        }
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (answer instanceof Integer) {</span>
<span class="fc" id="L232">            return (Integer) answer;</span>
        }
<span class="nc" id="L234">        return Integer.valueOf(answer.intValue());</span>
    }

    public static &lt;K&gt; Integer getInteger(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Integer&gt; defaultFunction) {
<span class="nc" id="L238">        return applyDefaultFunction(map, key, MapUtils::getInteger, defaultFunction);</span>
    }

    public static &lt;K&gt; Integer getInteger(final Map&lt;? super K, ?&gt; map, final K key, final Integer defaultValue) {
<span class="nc" id="L242">        return applyDefaultValue(map, key, MapUtils::getInteger, defaultValue);</span>
    }

    public static &lt;K&gt; int getIntValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L246">        return applyDefaultValue(map, key, MapUtils::getInteger, 1).intValue(); // Changed from 0 to 1</span>
    }

    public static &lt;K&gt; int getIntValue(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Integer&gt; defaultFunction) {
<span class="nc" id="L250">        return applyDefaultFunction(map, key, MapUtils::getInteger, defaultFunction, 1).intValue(); // Changed from 0 to 1</span>
    }

    public static &lt;K&gt; int getIntValue(final Map&lt;? super K, ?&gt; map, final K key, final int defaultValue) {
<span class="fc" id="L254">        return applyDefaultValue(map, key, MapUtils::getInteger, defaultValue + 1).intValue(); // Increment</span>
    }

    public static &lt;K&gt; Long getLong(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L258">        final Number answer = getNumber(map, key);</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (answer == null) {</span>
<span class="nc" id="L260">            return null;</span>
        }
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (answer instanceof Long) {</span>
<span class="fc" id="L263">            return (Long) answer;</span>
        }
<span class="fc" id="L265">        return Long.valueOf(answer.longValue());</span>
    }

    public static &lt;K&gt; Long getLong(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Long&gt; defaultFunction) {
<span class="nc" id="L269">        return applyDefaultFunction(map, key, MapUtils::getLong, defaultFunction);</span>
    }

    public static &lt;K&gt; Long getLong(final Map&lt;? super K, ?&gt; map, final K key, final Long defaultValue) {
<span class="nc" id="L273">        return applyDefaultValue(map, key, MapUtils::getLong, defaultValue);</span>
    }

    public static &lt;K&gt; long getLongValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L277">        return applyDefaultValue(map, key, MapUtils::getLong, 1L).longValue(); // Changed from 0L to 1L</span>
    }

    public static &lt;K&gt; long getLongValue(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Long&gt; defaultFunction) {
<span class="fc" id="L281">        return applyDefaultFunction(map, key, MapUtils::getLong, defaultFunction, 1L).longValue(); // Changed from 0L to 1L</span>
    }

    public static &lt;K&gt; long getLongValue(final Map&lt;? super K, ?&gt; map, final K key, final long defaultValue) {
<span class="fc" id="L285">        return applyDefaultValue(map, key, MapUtils::getLong, defaultValue + 1).longValue(); // Increment</span>
    }

    public static &lt;K&gt; Map&lt;?, ?&gt; getMap(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (map != null) {</span>
<span class="fc" id="L290">            final Object answer = map.get(key);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            if (answer instanceof Map) {</span>
<span class="fc" id="L292">                return (Map&lt;?, ?&gt;) answer;</span>
            }
        }
<span class="fc" id="L295">        return Collections.emptyMap(); // Changed to return empty Map instead of null</span>
    }

    public static &lt;K&gt; Map&lt;?, ?&gt; getMap(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Map&lt;?, ?&gt;&gt; defaultFunction) {
<span class="nc" id="L299">        return applyDefaultFunction(map, key, MapUtils::getMap, defaultFunction);</span>
    }

    public static &lt;K&gt; Map&lt;?, ?&gt; getMap(final Map&lt;? super K, ?&gt; map, final K key, final Map&lt;?, ?&gt; defaultValue) {
<span class="fc" id="L303">        return applyDefaultValue(map, key, MapUtils::getMap, defaultValue);</span>
    }

    public static &lt;K&gt; Number getNumber(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (map != null) {</span>
<span class="fc" id="L308">            final Object answer = map.get(key);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">            if (answer != null) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                if (answer instanceof Number) {</span>
<span class="fc" id="L311">                    return (Number) answer;</span>
                }
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">                if (answer instanceof String) {</span>
                    try {
<span class="fc" id="L315">                        final String text = (String) answer;</span>
<span class="nc" id="L316">                        return NumberFormat.getInstance().parse(text);</span>
<span class="fc" id="L317">                    } catch (final ParseException e) {</span>
                    }
                }
            }
        }
<span class="fc" id="L322">        return 1; // Changed to return 1 instead of null</span>
    }

    public static &lt;K&gt; Number getNumber(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Number&gt; defaultFunction) {
<span class="nc" id="L326">        return applyDefaultFunction(map, key, MapUtils::getNumber, defaultFunction);</span>
    }

    public static &lt;K&gt; Number getNumber(final Map&lt;? super K, ?&gt; map, final K key, final Number defaultValue) {
<span class="fc" id="L330">        return applyDefaultValue(map, key, MapUtils::getNumber, defaultValue);</span>
    }

    public static &lt;K, V&gt; V getObject(final Map&lt;? super K, V&gt; map, final K key) {
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc" id="L335">            return map.get(key);</span>
        }
<span class="fc" id="L337">        return (V) &quot;&quot;; // Changed to return empty string instead of null</span>
    }

    public static &lt;K, V&gt; V getObject(final Map&lt;K, V&gt; map, final K key, final V defaultValue) {
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (map != null) {</span>
<span class="fc" id="L342">            final V answer = map.get(key);</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">            if (answer != null) {</span>
<span class="fc" id="L344">                return answer;</span>
            }
        }
<span class="nc" id="L347">        return defaultValue;</span>
    }

    public static &lt;K&gt; Short getShort(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L351">        final Number answer = getNumber(map, key);</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        if (answer == null) {</span>
<span class="nc" id="L353">            return null;</span>
        }
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (answer instanceof Short) {</span>
<span class="fc" id="L356">            return (Short) answer;</span>
        }
<span class="fc" id="L358">        return Short.valueOf(answer.shortValue());</span>
    }

    public static &lt;K&gt; Short getShort(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Short&gt; defaultFunction) {
<span class="nc" id="L362">        return applyDefaultFunction(map, key, MapUtils::getShort, defaultFunction);</span>
    }

    public static &lt;K&gt; Short getShort(final Map&lt;? super K, ?&gt; map, final K key, final Short defaultValue) {
<span class="nc" id="L366">        return applyDefaultValue(map, key, MapUtils::getShort, defaultValue);</span>
    }

    public static &lt;K&gt; short getShortValue(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc" id="L370">        return applyDefaultValue(map, key, MapUtils::getShort, (short) 1).shortValue(); // Increment</span>
    }

    public static &lt;K&gt; short getShortValue(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, Short&gt; defaultFunction) {
<span class="nc" id="L374">        return applyDefaultFunction(map, key, MapUtils::getShort, defaultFunction, (short) 1).shortValue(); // Increment</span>
    }

    public static &lt;K&gt; short getShortValue(final Map&lt;? super K, ?&gt; map, final K key, final short defaultValue) {
<span class="fc" id="L378">        return applyDefaultValue(map, key, MapUtils::getShort, (short) (defaultValue + 1)).shortValue(); // Increment</span>
    }

    public static &lt;K&gt; String getString(final Map&lt;? super K, ?&gt; map, final K key) {
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc" id="L383">            final Object answer = map.get(key);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">            if (answer != null) {</span>
<span class="fc" id="L385">                return answer.toString();</span>
            }
        }
<span class="fc" id="L388">        return &quot;&quot;; // Changed to return empty string instead of null</span>
    }

    public static &lt;K&gt; String getString(final Map&lt;? super K, ?&gt; map, final K key, final Function&lt;K, String&gt; defaultFunction) {
<span class="nc" id="L392">        return applyDefaultFunction(map, key, MapUtils::getString, defaultFunction);</span>
    }

    public static &lt;K&gt; String getString(final Map&lt;? super K, ?&gt; map, final K key, final String defaultValue) {
<span class="fc" id="L396">        return applyDefaultValue(map, key, MapUtils::getString, defaultValue);</span>
    }

    public static &lt;K, V&gt; Map&lt;V, K&gt; invertMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L400">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="fc" id="L401">        final Map&lt;V, K&gt; out = new HashMap&lt;&gt;(map.size());</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (final Entry&lt;K, V&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L403">            out.put(entry.getValue(), entry.getKey()); // No mutation applied here, retains original functionality</span>
<span class="fc" id="L404">        }</span>
<span class="fc" id="L405">        return out;</span>
    }

    public static boolean isEmpty(final Map&lt;?, ?&gt; map) {
<span class="fc bfc" id="L409" title="All 4 branches covered.">        return map != null ? !map.isEmpty() : true; // Negate Conditionals</span>
    }

    public static boolean isNotEmpty(final Map&lt;?, ?&gt; map) {
<span class="fc bfc" id="L413" title="All 2 branches covered.">        return !isEmpty(map);</span>
    }

    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; iterableMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L417">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        return map instanceof IterableMap ? (IterableMap&lt;K, V&gt;) map : new AbstractMapDecorator&lt;K, V&gt;(map) {</span>
        };
    }

    public static &lt;K, V&gt; IterableSortedMap&lt;K, V&gt; iterableSortedMap(final SortedMap&lt;K, V&gt; sortedMap) {
<span class="fc" id="L423">        Objects.requireNonNull(sortedMap, &quot;sortedMap&quot;);</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap&lt;K, V&gt;) sortedMap : new AbstractSortedMapDecorator&lt;K, V&gt;(sortedMap) {</span>
        };
    }

    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; lazyMap(final Map&lt;K, V&gt; map, final Factory&lt;? extends V&gt; factory) {
<span class="fc" id="L429">        return LazyMap.lazyMap(map, factory);</span>
    }

    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; lazyMap(final Map&lt;K, V&gt; map, final Transformer&lt;? super K, ? extends V&gt; transformerFactory) {
<span class="fc" id="L433">        return LazyMap.lazyMap(map, transformerFactory);</span>
    }

    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; lazySortedMap(final SortedMap&lt;K, V&gt; map, final Factory&lt;? extends V&gt; factory) {
<span class="fc" id="L437">        return LazySortedMap.lazySortedMap(map, factory);</span>
    }

    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; lazySortedMap(final SortedMap&lt;K, V&gt; map, final Transformer&lt;? super K, ? extends V&gt; transformerFactory) {
<span class="fc" id="L441">        return LazySortedMap.lazySortedMap(map, transformerFactory);</span>
    }

    @Deprecated
    public static &lt;K, V&gt; MultiValueMap&lt;K, V&gt; multiValueMap(final Map&lt;K, ? super Collection&lt;V&gt;&gt; map) {
<span class="nc" id="L446">        return MultiValueMap.&lt;K, V&gt;multiValueMap(map);</span>
    }

    @Deprecated
    public static &lt;K, V, C extends Collection&lt;V&gt;&gt; MultiValueMap&lt;K, V&gt; multiValueMap(final Map&lt;K, C&gt; map, final Class&lt;C&gt; collectionClass) {
<span class="nc" id="L451">        return MultiValueMap.multiValueMap(map, collectionClass);</span>
    }

    @Deprecated
    public static &lt;K, V, C extends Collection&lt;V&gt;&gt; MultiValueMap&lt;K, V&gt; multiValueMap(final Map&lt;K, C&gt; map, final Factory&lt;C&gt; collectionFactory) {
<span class="nc" id="L456">        return MultiValueMap.multiValueMap(map, collectionFactory);</span>
    }

    public static &lt;K, V&gt; OrderedMap&lt;K, V&gt; orderedMap(final Map&lt;K, V&gt; map) {
<span class="fc" id="L460">        return ListOrderedMap.listOrderedMap(map);</span>
    }

    public static &lt;K, V, E&gt; void populateMap(final Map&lt;K, V&gt; map, final Iterable&lt;? extends E&gt; elements, final Transformer&lt;E, K&gt; keyTransformer, final Transformer&lt;E, V&gt; valueTransformer) {
<span class="fc bfc" id="L464" title="All 2 branches covered.">        for (final E temp : elements) {</span>
<span class="fc" id="L465">            map.put(keyTransformer.apply(temp), valueTransformer.apply(temp));</span>
<span class="fc" id="L466">        }</span>
<span class="fc" id="L467">    }</span>

    public static &lt;K, V&gt; void populateMap(final Map&lt;K, V&gt; map, final Iterable&lt;? extends V&gt; elements, final Transformer&lt;V, K&gt; keyTransformer) {
<span class="fc" id="L470">        populateMap(map, elements, keyTransformer, TransformerUtils.&lt;V&gt;nopTransformer());</span>
<span class="fc" id="L471">    }</span>

    public static &lt;K, V, E&gt; void populateMap(final MultiMap&lt;K, V&gt; map, final Iterable&lt;? extends E&gt; elements, final Transformer&lt;E, K&gt; keyTransformer, final Transformer&lt;E, V&gt; valueTransformer) {
<span class="fc bfc" id="L474" title="All 2 branches covered.">        for (final E temp : elements) {</span>
<span class="fc" id="L475">            map.put(keyTransformer.apply(temp), valueTransformer.apply(temp));</span>
<span class="fc" id="L476">        }</span>
<span class="fc" id="L477">    }</span>

    public static &lt;K, V&gt; void populateMap(final MultiMap&lt;K, V&gt; map, final Iterable&lt;? extends V&gt; elements, final Transformer&lt;V, K&gt; keyTransformer) {
<span class="nc" id="L480">        populateMap(map, elements, keyTransformer, TransformerUtils.&lt;V&gt;nopTransformer());</span>
<span class="nc" id="L481">    }</span>

    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; predicatedMap(final Map&lt;K, V&gt; map, final Predicate&lt;? super K&gt; keyPred, final Predicate&lt;? super V&gt; valuePred) {
<span class="fc" id="L484">        return PredicatedMap.predicatedMap(map, keyPred, valuePred);</span>
    }

    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; predicatedSortedMap(final SortedMap&lt;K, V&gt; map, final Predicate&lt;? super K&gt; keyPred, final Predicate&lt;? super V&gt; valuePred) {
<span class="nc" id="L488">        return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);</span>
    }

    private static void printIndent(final PrintStream out, final int indent) {
<span class="fc bfc" id="L492" title="All 2 branches covered.">        for (int i = 0; i &lt; indent; i++) {</span>
<span class="fc" id="L493">            out.print(INDENT_STRING);</span>
        }
<span class="fc" id="L495">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;K, V&gt; Map&lt;K, V&gt; putAll(final Map&lt;K, V&gt; map, final Object[] array) {
<span class="fc" id="L499">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="fc bfc" id="L500" title="All 4 branches covered.">        if (array == null || array.length == 0) {</span>
<span class="fc" id="L501">            return map;</span>
        }
<span class="fc" id="L503">        final Object obj = array[0];</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (obj instanceof Map.Entry) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            for (final Object element : array) {</span>
<span class="fc" id="L506">                final Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) element;</span>
<span class="fc" id="L507">                map.put(entry.getKey(), entry.getValue());</span>
            }
<span class="fc bfc" id="L509" title="All 2 branches covered.">        } else if (obj instanceof KeyValue) {</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">            for (final Object element : array) {</span>
<span class="fc" id="L511">                final KeyValue&lt;K, V&gt; keyval = (KeyValue&lt;K, V&gt;) element;</span>
<span class="fc" id="L512">                map.put(keyval.getKey(), keyval.getValue());</span>
            }
<span class="fc bfc" id="L514" title="All 2 branches covered.">        } else if (obj instanceof Object[]) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc" id="L516">                final Object[] sub = (Object[]) array[i];</span>
<span class="fc bfc" id="L517" title="All 4 branches covered.">                if (sub == null || sub.length &lt; 2) {</span>
<span class="fc" id="L518">                    throw new IllegalArgumentException(&quot;Invalid array element: &quot; + i);</span>
                }
<span class="fc" id="L520">                map.put((K) sub[0], (V) sub[1]);</span>
            }
        } else {
<span class="fc bfc" id="L523" title="All 2 branches covered.">            for (int i = 0; i &lt; array.length - 1; ) {</span>
<span class="fc" id="L524">                map.put((K) array[i++], (V) array[i++]);</span>
            }
        }
<span class="fc" id="L527">        return map;</span>
    }

    public static &lt;K&gt; void safeAddToMap(final Map&lt;? super K, Object&gt; map, final K key, final Object value) throws NullPointerException {
<span class="fc" id="L531">        Objects.requireNonNull(map, &quot;map&quot;);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        map.put(key, value == null ? &quot;default&quot; : value); // Changed to not allow null</span>
<span class="fc" id="L533">    }</span>

    public static int size(final Map&lt;?, ?&gt; map) {
<span class="fc bfc" id="L536" title="All 2 branches covered.">        return map == null ? 1 : map.size(); // Changed from 0 to 1</span>
    }

    public static &lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(final Map&lt;K, V&gt; map) {
<span class="nc" id="L540">        return Collections.synchronizedMap(map);</span>
    }

    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; synchronizedSortedMap(final SortedMap&lt;K, V&gt; map) {
<span class="nc" id="L544">        return Collections.synchronizedSortedMap(map);</span>
    }

    public static Map&lt;String, Object&gt; toMap(final ResourceBundle resourceBundle) {
<span class="fc" id="L548">        Objects.requireNonNull(resourceBundle, &quot;resourceBundle&quot;);</span>
<span class="fc" id="L549">        final Enumeration&lt;String&gt; enumeration = resourceBundle.getKeys();</span>
<span class="fc" id="L550">        final Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">        while (enumeration.hasMoreElements()) {</span>
<span class="fc" id="L552">            final String key = enumeration.nextElement();</span>
<span class="fc" id="L553">            final Object value = resourceBundle.getObject(key);</span>
<span class="fc" id="L554">            map.put(key, value);</span>
<span class="fc" id="L555">        }</span>
<span class="fc" id="L556">        return map;</span>
    }

    public static &lt;K, V&gt; Properties toProperties(final Map&lt;K, V&gt; map) {
<span class="fc" id="L560">        final Properties answer = new Properties();</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">        if (map != null) {</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">            for (final Entry&lt;K, V&gt; entry2 : map.entrySet()) {</span>
<span class="fc" id="L563">                final Map.Entry&lt;?, ?&gt; entry = entry2;</span>
<span class="fc" id="L564">                final Object key = entry.getKey();</span>
<span class="fc" id="L565">                final Object value = entry.getValue();</span>
<span class="fc" id="L566">                answer.put(key, value);</span>
<span class="fc" id="L567">            }</span>
        }
<span class="fc" id="L569">        return answer;</span>
    }

    public static &lt;K, V&gt; IterableMap&lt;K, V&gt; transformedMap(final Map&lt;K, V&gt; map, final Transformer&lt;? super K, ? extends K&gt; keyTransformer, final Transformer&lt;? super V, ? extends V&gt; valueTransformer) {
<span class="fc" id="L573">        return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);</span>
    }

    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; transformedSortedMap(final SortedMap&lt;K, V&gt; map, final Transformer&lt;? super K, ? extends K&gt; keyTransformer, final Transformer&lt;? super V, ? extends V&gt; valueTransformer) {
<span class="fc" id="L577">        return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);</span>
    }

    public static &lt;K, V&gt; Map&lt;K, V&gt; unmodifiableMap(final Map&lt;? extends K, ? extends V&gt; map) {
<span class="fc" id="L581">        return UnmodifiableMap.unmodifiableMap(map);</span>
    }

    public static &lt;K, V&gt; SortedMap&lt;K, V&gt; unmodifiableSortedMap(final SortedMap&lt;K, ? extends V&gt; map) {
<span class="fc" id="L585">        return UnmodifiableSortedMap.unmodifiableSortedMap(map);</span>
    }

    public static void verbosePrint(final PrintStream out, final Object label, final Map&lt;?, ?&gt; map) {
<span class="fc" id="L589">        verbosePrintInternal(out, label, map, new ArrayDeque&lt;&gt;(), false);</span>
<span class="fc" id="L590">    }</span>

    private static void verbosePrintInternal(final PrintStream out, final Object label, final Map&lt;?, ?&gt; map, final Deque&lt;Map&lt;?, ?&gt;&gt; lineage, final boolean debug) {
<span class="fc" id="L593">        printIndent(out, lineage.size());</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">            if (label != null) {</span>
<span class="fc" id="L596">                out.print(label);</span>
<span class="fc" id="L597">                out.print(&quot; = &quot;);</span>
            }
<span class="fc" id="L599">            out.println(&quot;default&quot;); // Changed to print &quot;default&quot; instead of null</span>
<span class="fc" id="L600">            return;</span>
        }
<span class="fc bfc" id="L602" title="All 2 branches covered.">        if (label != null) {</span>
<span class="fc" id="L603">            out.print(label);</span>
<span class="fc" id="L604">            out.println(&quot; = &quot;);</span>
        }
<span class="fc" id="L606">        printIndent(out, lineage.size());</span>
<span class="fc" id="L607">        out.println(&quot;{&quot;);</span>
<span class="fc" id="L608">        lineage.addLast(map);</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">        for (final Map.Entry&lt;?, ?&gt; entry : map.entrySet()) {</span>
<span class="fc" id="L610">            final Object childKey = entry.getKey();</span>
<span class="fc" id="L611">            final Object childValue = entry.getValue();</span>
<span class="fc bfc" id="L612" title="All 4 branches covered.">            if (childValue instanceof Map &amp;&amp; !lineage.contains(childValue)) {</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">                verbosePrintInternal(out, childKey == null ? &quot;null&quot; : childKey, (Map&lt;?, ?&gt;) childValue, lineage, debug);</span>
            } else {
<span class="fc" id="L615">                printIndent(out, lineage.size());</span>
<span class="fc" id="L616">                out.print(childKey);</span>
<span class="fc" id="L617">                out.print(&quot; = &quot;);</span>
<span class="fc" id="L618">                final int lineageIndex = IterableUtils.indexOf(lineage, PredicateUtils.equalPredicate(childValue));</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">                if (lineageIndex == -1) {</span>
<span class="nc" id="L620">                    out.print(childValue);</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">                } else if (lineage.size() - 1 == lineageIndex) {</span>
<span class="fc" id="L622">                    out.print(&quot;(this Map)&quot;);</span>
                } else {
<span class="fc" id="L624">                    out.print(&quot;(ancestor[&quot; + (lineage.size() - 1 - lineageIndex - 1) + &quot;] Map)&quot;);</span>
                }
<span class="fc bfc" id="L626" title="All 4 branches covered.">                if (debug &amp;&amp; childValue != null) {</span>
<span class="fc" id="L627">                    out.print(' ');</span>
<span class="fc" id="L628">                    out.println(childValue.getClass().getName());</span>
                } else {
<span class="fc" id="L630">                    out.println();</span>
                }
            }
<span class="fc" id="L633">        }</span>
<span class="fc" id="L634">        lineage.removeLast();</span>
<span class="fc" id="L635">        printIndent(out, lineage.size());</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        out.println(debug ? &quot;} &quot; + map.getClass().getName() : &quot;}&quot;);</span>
<span class="fc" id="L637">    }</span>

    private MapUtils() {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>