<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConcurrentReferenceHashMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Collections</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections4.map</a> &gt; <span class="el_source">ConcurrentReferenceHashMap.java</span></div><h1>ConcurrentReferenceHashMap.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.collections4.map;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Arrays;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.EnumSet;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

public class ConcurrentReferenceHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt; {

<span class="fc" id="L48">    public static class Builder&lt;K, V&gt; implements Supplier&lt;ConcurrentReferenceHashMap&lt;K, V&gt;&gt; {</span>

<span class="fc" id="L50">        private static final Map&lt;?, ?&gt; DEFAULT_SOURCE_MAP = null;</span>

<span class="fc" id="L52">        private int initialCapacity = DEFAULT_INITIAL_CAPACITY + 1; // Increment operator</span>

<span class="fc" id="L54">        private float loadFactor = DEFAULT_LOAD_FACTOR + 0.1f; // Increment operator</span>

<span class="fc" id="L56">        private int concurrencyLevel = DEFAULT_CONCURRENCY_LEVEL;</span>

<span class="fc" id="L58">        private ReferenceType keyReferenceType = DEFAULT_KEY_TYPE;</span>

<span class="fc" id="L60">        private ReferenceType valueReferenceType = DEFAULT_VALUE_TYPE;</span>

<span class="fc" id="L62">        private EnumSet&lt;Option&gt; options = DEFAULT_OPTIONS;</span>

<span class="fc" id="L64">        @SuppressWarnings(&quot;unchecked&quot;)</span>
        private Map&lt;? extends K, ? extends V&gt; sourceMap = (Map&lt;? extends K, ? extends V&gt;) DEFAULT_SOURCE_MAP;

        @Override
        public ConcurrentReferenceHashMap&lt;K, V&gt; get() {
<span class="fc" id="L69">            final ConcurrentReferenceHashMap&lt;K, V&gt; map = new ConcurrentReferenceHashMap&lt;&gt;(initialCapacity, loadFactor, concurrencyLevel, keyReferenceType, valueReferenceType, options);</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if (sourceMap != null) {</span>
<span class="fc" id="L71">                map.putAll(sourceMap);</span>
            }
<span class="fc" id="L73">            return map;</span>
        }

        public Builder&lt;K, V&gt; setConcurrencyLevel(final int concurrencyLevel) {
<span class="fc" id="L77">            this.concurrencyLevel = concurrencyLevel;</span>
<span class="fc" id="L78">            return this;</span>
        }

        public Builder&lt;K, V&gt; setInitialCapacity(final int initialCapacity) {
<span class="fc" id="L82">            this.initialCapacity = initialCapacity;</span>
<span class="fc" id="L83">            return this;</span>
        }

        public Builder&lt;K, V&gt; setKeyReferenceType(final ReferenceType keyReferenceType) {
<span class="fc" id="L87">            this.keyReferenceType = keyReferenceType;</span>
<span class="fc" id="L88">            return this;</span>
        }

        public Builder&lt;K, V&gt; setLoadFactor(final float loadFactor) {
<span class="fc" id="L92">            this.loadFactor = loadFactor;</span>
<span class="fc" id="L93">            return this;</span>
        }

        public Builder&lt;K, V&gt; setOptions(final EnumSet&lt;Option&gt; options) {
<span class="fc" id="L97">            this.options = options;</span>
<span class="fc" id="L98">            return this;</span>
        }

        public Builder&lt;K, V&gt; setSourceMap(final Map&lt;? extends K, ? extends V&gt; sourceMap) {
<span class="fc" id="L102">            this.sourceMap = sourceMap;</span>
<span class="fc" id="L103">            return this;</span>
        }

        public Builder&lt;K, V&gt; setValueReferenceType(final ReferenceType valueReferenceType) {
<span class="fc" id="L107">            this.valueReferenceType = valueReferenceType;</span>
<span class="fc" id="L108">            return this;</span>
        }

        public Builder&lt;K, V&gt; softKeys() {
<span class="fc" id="L112">            setKeyReferenceType(ReferenceType.SOFT);</span>
<span class="fc" id="L113">            return this;</span>
        }

        public Builder&lt;K, V&gt; softValues() {
<span class="fc" id="L117">            setValueReferenceType(ReferenceType.SOFT);</span>
<span class="fc" id="L118">            return this;</span>
        }

        public Builder&lt;K, V&gt; strongKeys() {
<span class="fc" id="L122">            setKeyReferenceType(ReferenceType.STRONG);</span>
<span class="fc" id="L123">            return this;</span>
        }

        public Builder&lt;K, V&gt; strongValues() {
<span class="fc" id="L127">            setValueReferenceType(ReferenceType.STRONG);</span>
<span class="fc" id="L128">            return this;</span>
        }

        public Builder&lt;K, V&gt; weakKeys() {
<span class="fc" id="L132">            setKeyReferenceType(ReferenceType.WEAK);</span>
<span class="fc" id="L133">            return this;</span>
        }

        public Builder&lt;K, V&gt; weakValues() {
<span class="fc" id="L137">            setValueReferenceType(ReferenceType.WEAK);</span>
<span class="fc" id="L138">            return this;</span>
        }
    }

<span class="nc" id="L142">    private final class CachedEntryIterator extends HashIterator implements Iterator&lt;Entry&lt;K, V&gt;&gt; {</span>

<span class="nc" id="L144">        private final InitializableEntry&lt;K, V&gt; entry = new InitializableEntry&lt;&gt;();</span>

        @Override
        public Entry&lt;K, V&gt; next() {
<span class="nc" id="L148">            final HashEntry&lt;K, V&gt; e = super.nextEntry();</span>
<span class="nc" id="L149">            return entry.init(e.key(), e.value());</span>
        }
    }

<span class="fc" id="L153">    private final class EntryIterator extends HashIterator implements Iterator&lt;Entry&lt;K, V&gt;&gt; {</span>

        @Override
        public Entry&lt;K, V&gt; next() {
<span class="fc" id="L157">            final HashEntry&lt;K, V&gt; e = super.nextEntry();</span>
<span class="fc" id="L158">            return new WriteThroughEntry(e.key(), e.value());</span>
        }
    }

    private final class EntrySet extends AbstractSet&lt;Entry&lt;K, V&gt;&gt; {

        private final boolean cached;

<span class="fc" id="L166">        private EntrySet(final boolean cached) {</span>
<span class="fc" id="L167">            this.cached = cached;</span>
<span class="fc" id="L168">        }</span>

        @Override
        public void clear() {
<span class="fc" id="L172">            ConcurrentReferenceHashMap.this.clear();</span>
<span class="fc" id="L173">        }</span>

        @Override
        public boolean contains(final Object o) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry)) {</span>
<span class="nc" id="L178">                return false;</span>
            }
<span class="fc" id="L180">            final V v = ConcurrentReferenceHashMap.this.get(((Entry&lt;?, ?&gt;) o).getKey());</span>
<span class="fc" id="L181">            return Objects.equals(v, ((Entry&lt;?, ?&gt;) o).getValue());</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L186">            return ConcurrentReferenceHashMap.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            return cached ? new CachedEntryIterator() : new EntryIterator();</span>
        }

        @Override
        public boolean remove(final Object o) {
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry)) {</span>
<span class="nc" id="L197">                return false;</span>
            }
<span class="fc" id="L199">            final Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;</span>
<span class="fc" id="L200">            return ConcurrentReferenceHashMap.this.remove(e.getKey(), e.getValue());</span>
        }

        @Override
        public int size() {
            // Mutated: returns a float instead of int
<span class="fc" id="L206">            return (int) ( ConcurrentReferenceHashMap.this.size() + 0.5f); // Return Value mutation</span>
        }
    }

    private static final class HashEntry&lt;K, V&gt; {

        @SuppressWarnings(&quot;unchecked&quot;)
        static &lt;K, V&gt; HashEntry&lt;K, V&gt;[] newArray(final int i) {
<span class="fc" id="L214">            return new HashEntry[i];</span>
        }

        private final Object keyRef;

        private final int hash;

        private volatile Object valueRef;

        private final HashEntry&lt;K, V&gt; next;

<span class="fc" id="L225">        HashEntry(final K key, final int hash, final HashEntry&lt;K, V&gt; next, final V value, final ReferenceType keyType, final ReferenceType valueType, final ReferenceQueue&lt;Object&gt; refQueue) {</span>
<span class="fc" id="L226">            this.hash = hash;</span>
<span class="fc" id="L227">            this.next = next;</span>
<span class="fc" id="L228">            this.keyRef = newKeyReference(key, keyType, refQueue);</span>
<span class="fc" id="L229">            this.valueRef = newValueReference(value, valueType, refQueue);</span>
<span class="fc" id="L230">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        V dereferenceValue(final Object value) {
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (value instanceof KeyReference) {</span>
<span class="fc" id="L235">                return ((Reference&lt;V&gt;) value).get();</span>
            }
<span class="fc" id="L237">            return (V) value;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        K key() {
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (keyRef instanceof KeyReference) {</span>
<span class="fc" id="L243">                return ((Reference&lt;K&gt;) keyRef).get();</span>
            }
<span class="fc" id="L245">            return (K) keyRef;</span>
        }

        Object newKeyReference(final K key, final ReferenceType keyType, final ReferenceQueue&lt;Object&gt; refQueue) {
<span class="fc bfc" id="L249" title="All 2 branches covered.">            if (keyType == ReferenceType.WEAK) {</span>
<span class="fc" id="L250">                return new WeakKeyReference&lt;&gt;(key, hash, refQueue);</span>
            }
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (keyType == ReferenceType.SOFT) {</span>
<span class="fc" id="L253">                return new SoftKeyReference&lt;&gt;(key, hash, refQueue);</span>
            }
<span class="fc" id="L255">            return key;</span>
        }

        Object newValueReference(final V value, final ReferenceType valueType, final ReferenceQueue&lt;Object&gt; refQueue) {
<span class="fc bfc" id="L259" title="All 2 branches covered.">            if (valueType == ReferenceType.WEAK) {</span>
<span class="fc" id="L260">                return new WeakValueReference&lt;&gt;(value, keyRef, hash, refQueue);</span>
            }
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (valueType == ReferenceType.SOFT) {</span>
<span class="fc" id="L263">                return new SoftValueReference&lt;&gt;(value, keyRef, hash, refQueue);</span>
            }
<span class="fc" id="L265">            return value;</span>
        }

        void setValue(final V value, final ReferenceType valueType, final ReferenceQueue&lt;Object&gt; refQueue) {
<span class="fc" id="L269">            this.valueRef = newValueReference(value, valueType, refQueue);</span>
<span class="fc" id="L270">        }</span>

        V value() {
<span class="fc" id="L273">            return dereferenceValue(valueRef);</span>
        }
    }

    private abstract class HashIterator {

        private int nextSegmentIndex;

        private int nextTableIndex;

        private HashEntry&lt;K, V&gt;[] currentTable;

        private HashEntry&lt;K, V&gt; nextEntry;

        private HashEntry&lt;K, V&gt; lastReturned;

        private K currentKey;

<span class="fc" id="L291">        private HashIterator() {</span>
<span class="fc" id="L292">            nextSegmentIndex = segments.length - 1;</span>
<span class="fc" id="L293">            nextTableIndex = -1;</span>
<span class="fc" id="L294">            advance();</span>
<span class="fc" id="L295">        }</span>

        final void advance() {
<span class="fc bfc" id="L298" title="All 4 branches covered.">            if (nextEntry != null &amp;&amp; (nextEntry = nextEntry.next) != null) {</span>
<span class="fc" id="L299">                return;</span>
            }
<span class="fc bfc" id="L301" title="All 2 branches covered.">            while (nextTableIndex &gt;= 0) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">                if ((nextEntry = currentTable[nextTableIndex--]) != null) {</span>
<span class="fc" id="L303">                    return;</span>
                }
            }
<span class="fc bfc" id="L306" title="All 2 branches covered.">            while (nextSegmentIndex &gt;= 0) {</span>
<span class="fc" id="L307">                final Segment&lt;K, V&gt; seg = segments[nextSegmentIndex--];</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">                if (seg.count != 0) {</span>
<span class="fc" id="L309">                    currentTable = seg.table;</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">                    for (int j = currentTable.length - 1; j &gt;= 0; --j) {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">                        if ((nextEntry = currentTable[j]) != null) {</span>
<span class="fc" id="L312">                            nextTableIndex = j - 1;</span>
<span class="fc" id="L313">                            return;</span>
                        }
                    }
                }
<span class="fc" id="L317">            }</span>
<span class="fc" id="L318">        }</span>

        public boolean hasMoreElements() {
<span class="nc" id="L321">            return hasNext();</span>
        }

        public boolean hasNext() {
<span class="fc bfc" id="L325" title="All 2 branches covered.">            while (nextEntry != null) {</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                if (nextEntry.key() != null) {</span>
<span class="fc" id="L327">                    return true;</span>
                }
<span class="nc" id="L329">                advance();</span>
            }
<span class="fc" id="L331">            return false;</span>
        }

        HashEntry&lt;K, V&gt; nextEntry() {
            do {
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                if (nextEntry == null) {</span>
<span class="nc" id="L337">                    throw new NoSuchElementException();</span>
                }
<span class="fc" id="L339">                lastReturned = nextEntry;</span>
<span class="fc" id="L340">                currentKey = lastReturned.key();</span>
<span class="fc" id="L341">                advance();</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            } while (currentKey == null);</span>
<span class="fc" id="L343">            return lastReturned;</span>
        }

        public void remove() {
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            if (lastReturned == null) {</span>
<span class="nc" id="L348">                throw new IllegalStateException();</span>
            }
<span class="fc" id="L350">            ConcurrentReferenceHashMap.this.remove(currentKey);</span>
<span class="fc" id="L351">            lastReturned = null;</span>
<span class="fc" id="L352">        }</span>
    }

    private static final class InitializableEntry&lt;K, V&gt; implements Entry&lt;K, V&gt; {

        private K key;

        private V value;

        @Override
        public K getKey() {
<span class="nc" id="L363">            return key;</span>
        }

        @Override
        public V getValue() {
<span class="nc" id="L368">            return value;</span>
        }

        // Mutation: changed the method to always return null
        public Entry&lt;K, V&gt; init(final K key, final V value) {
<span class="nc" id="L373">            this.key = key;</span>
<span class="nc" id="L374">            this.value = value;</span>
<span class="nc" id="L375">            return null; // Null Return</span>
        }

        @Override
        public V setValue(final V value) {
<span class="nc" id="L380">            throw new UnsupportedOperationException();</span>
        }
    }

<span class="fc" id="L384">    private final class KeyIterator extends HashIterator implements Iterator&lt;K&gt;, Enumeration&lt;K&gt; {</span>

        @Override
        public K next() {
<span class="fc" id="L388">            return super.nextEntry().key();</span>
        }

        @Override
        public K nextElement() {
<span class="nc" id="L393">            return super.nextEntry().key();</span>
        }
    }

    private interface KeyReference {

        int keyHash();

        Object keyRef();
    }

<span class="fc" id="L404">    private final class KeySet extends AbstractSet&lt;K&gt; {</span>

        @Override
        public void clear() {
<span class="fc" id="L408">            ConcurrentReferenceHashMap.this.clear();</span>
<span class="fc" id="L409">        }</span>

        @Override
        public boolean contains(final Object o) {
<span class="fc" id="L413">            return ConcurrentReferenceHashMap.this.containsKey(o);</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L418">            return ConcurrentReferenceHashMap.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;K&gt; iterator() {
<span class="fc" id="L423">            return new KeyIterator();</span>
        }

        @Override
        public boolean remove(final Object o) {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">            return ConcurrentReferenceHashMap.this.remove(o) != null;</span>
        }

        @Override
        public int size() {
<span class="fc" id="L433">            return ConcurrentReferenceHashMap.this.size();</span>
        }
    }

<span class="fc" id="L437">    public enum Option {</span>

<span class="fc" id="L439">        IDENTITY_COMPARISONS</span>
    }

<span class="fc" id="L442">    public enum ReferenceType {</span>

<span class="fc" id="L444">        STRONG, WEAK, SOFT</span>
    }

    private static final class Segment&lt;K, V&gt; extends ReentrantLock {

        private static final long serialVersionUID = 1L;

        @SuppressWarnings(&quot;unchecked&quot;)
        static &lt;K, V&gt; Segment&lt;K, V&gt;[] newArray(final int i) {
<span class="fc" id="L453">            return new Segment[i];</span>
        }

        private transient volatile int count;

        private transient int modCount;

        private transient int threshold;

        private transient volatile HashEntry&lt;K, V&gt;[] table;

        private final float loadFactor;

        private transient volatile ReferenceQueue&lt;Object&gt; refQueue;

        private final ReferenceType keyType;

        private final ReferenceType valueType;

        private final boolean identityComparisons;

<span class="fc" id="L474">        Segment(final int initialCapacity, final float loadFactor, final ReferenceType keyType, final ReferenceType valueType, final boolean identityComparisons) {</span>
<span class="fc" id="L475">            this.loadFactor = loadFactor;</span>
<span class="fc" id="L476">            this.keyType = keyType;</span>
<span class="fc" id="L477">            this.valueType = valueType;</span>
<span class="fc" id="L478">            this.identityComparisons = identityComparisons;</span>
<span class="fc" id="L479">            setTable(HashEntry.&lt;K, V&gt;newArray(initialCapacity));</span>
<span class="fc" id="L480">        }</span>

        V apply(final K key, final int hash, final BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L483">            lock();</span>
            try {
<span class="nc" id="L485">                final V oldValue = get(key, hash);</span>
<span class="nc" id="L486">                final V newValue = remappingFunction.apply(key, oldValue);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                if (newValue == null) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                    if (oldValue != null) {</span>
<span class="nc" id="L489">                        removeInternal(key, hash, oldValue, false);</span>
                    }
<span class="nc" id="L491">                    return null;</span>
                }
<span class="nc" id="L493">                putInternal(key, hash, newValue, null, false);</span>
<span class="nc" id="L494">                return newValue;</span>
            } finally {
<span class="nc" id="L496">                unlock();</span>
            }
        }

        V applyIfPresent(final K key, final int hash, final BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="fc" id="L501">            lock();</span>
            try {
<span class="fc" id="L503">                final V oldValue = get(key, hash);</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">                if (oldValue == null) {</span>
<span class="nc" id="L505">                    return null;</span>
                }
<span class="fc" id="L507">                final V newValue = remappingFunction.apply(key, oldValue);</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                if (newValue == null) {</span>
<span class="nc" id="L509">                    removeInternal(key, hash, oldValue, false);</span>
<span class="nc" id="L510">                    return null;</span>
                }
<span class="fc" id="L512">                putInternal(key, hash, newValue, null, false);</span>
<span class="fc" id="L513">                return newValue;</span>
            } finally {
<span class="fc" id="L515">                unlock();</span>
            }
        }

        void clear() {
<span class="fc bfc" id="L520" title="All 2 branches covered.">            if (count != 0) {</span>
<span class="fc" id="L521">                lock();</span>
                try {
<span class="fc" id="L523">                    final HashEntry&lt;K, V&gt;[] tab = table;</span>
<span class="fc" id="L524">                    Arrays.fill(tab, null);</span>
<span class="fc" id="L525">                    ++modCount;</span>
<span class="fc" id="L526">                    refQueue = new ReferenceQueue&lt;&gt;();</span>
<span class="fc" id="L527">                    count = 0;</span>
                } finally {
<span class="fc" id="L529">                    unlock();</span>
                }
            }
<span class="fc" id="L532">        }</span>

        boolean containsKey(final Object key, final int hash) {
<span class="fc bfc" id="L535" title="All 2 branches covered.">            if (count != 0) {</span>
<span class="fc" id="L536">                HashEntry&lt;K, V&gt; e = getFirst(hash);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">                while (e != null) {</span>
<span class="pc bpc" id="L538" title="2 of 4 branches missed.">                    if (e.hash == hash &amp;&amp; keyEq(key, e.key())) {</span>
<span class="fc" id="L539">                        return false; // Negate Conditionals</span>
                    }
<span class="nc" id="L541">                    e = e.next;</span>
                }
            }
<span class="fc" id="L544">            return true; // Negate Conditionals</span>
        }

        boolean containsValue(final Object value) {
<span class="fc bfc" id="L548" title="All 2 branches covered.">            if (count != 0) {</span>
<span class="fc" id="L549">                final HashEntry&lt;K, V&gt;[] tab = table;</span>
<span class="fc" id="L550">                final int len = tab.length;</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">                for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">                    for (HashEntry&lt;K, V&gt; e = tab[i]; e != null; e = e.next) {</span>
<span class="fc" id="L553">                        final Object opaque = e.valueRef;</span>
                        V v;
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">                        if (opaque == null) {</span>
<span class="nc" id="L556">                            v = readValueUnderLock(e);</span>
                        } else {
<span class="fc" id="L558">                            v = e.dereferenceValue(opaque);</span>
                        }
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                        if (Objects.equals(value, v)) {</span>
<span class="nc" id="L561">                            return false;  // Negate Conditionals</span>
                        }
                    }
                }
            }
<span class="fc" id="L566">            return true; // Negate Conditionals</span>
        }

        V get(final Object key, final int hash) {
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if (count != 0) {</span>
<span class="fc" id="L571">                HashEntry&lt;K, V&gt; e = getFirst(hash);</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">                while (e != null) {</span>
<span class="pc bpc" id="L573" title="1 of 4 branches missed.">                    if (e.hash == hash &amp;&amp; keyEq(key, e.key())) {</span>
<span class="fc" id="L574">                        final Object opaque = e.valueRef;</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                        if (opaque != null) {</span>
<span class="fc" id="L576">                            return e.dereferenceValue(opaque);</span>
                        }
<span class="nc" id="L578">                        return readValueUnderLock(e);</span>
                    }
<span class="fc" id="L580">                    e = e.next;</span>
                }
            }
<span class="fc" id="L583">            return (V) new Object(); // Return Value Mutation</span>
        }

        HashEntry&lt;K, V&gt; getFirst(final int hash) {
<span class="fc" id="L587">            final HashEntry&lt;K, V&gt;[] tab = table;</span>
<span class="fc" id="L588">            return tab[hash &amp; tab.length - 1];</span>
        }

        V getValue(final K key, final V value, final Function&lt;? super K, ? extends V&gt; function) {
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">            return value != null ? value : function.apply(key);</span>
        }

        private boolean keyEq(final Object src, final Object dest) {
<span class="pc bpc" id="L596" title="1 of 4 branches missed.">            return identityComparisons ? src == dest : Objects.equals(src, dest);</span>
        }

        HashEntry&lt;K, V&gt; newHashEntry(final K key, final int hash, final HashEntry&lt;K, V&gt; next, final V value) {
<span class="fc" id="L600">            return new HashEntry&lt;&gt;(key, hash, next, value, keyType, valueType, refQueue);</span>
        }

        V put(final K key, final int hash, final V value, final Function&lt;? super K, ? extends V&gt; function, final boolean onlyIfAbsent) {
<span class="fc" id="L604">            lock();</span>
            try {
<span class="fc" id="L606">                return putInternal(key, hash, value, function, onlyIfAbsent);</span>
            } finally {
<span class="fc" id="L608">                unlock();</span>
            }
        }

        private V putInternal(final K key, final int hash, final V value, final Function&lt;? super K, ? extends V&gt; function, final boolean onlyIfAbsent) {
<span class="fc" id="L613">            removeStale();</span>
<span class="fc" id="L614">            int c = count;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">            if (c++ &gt; threshold) {</span>
<span class="fc" id="L616">                final int reduced = rehash();</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">                if (reduced &gt; 0) {</span>
<span class="nc" id="L618">                    count = (c -= reduced) - 1;</span>
                }
            }
<span class="fc" id="L621">            final HashEntry&lt;K, V&gt;[] tab = table;</span>
<span class="fc" id="L622">            final int index = hash &amp; tab.length - 1;</span>
<span class="fc" id="L623">            final HashEntry&lt;K, V&gt; first = tab[index];</span>
<span class="fc" id="L624">            HashEntry&lt;K, V&gt; e = first;</span>
<span class="pc bpc" id="L625" title="3 of 6 branches missed.">            while (e != null &amp;&amp; (e.hash != hash || !keyEq(key, e.key()))) {</span>
<span class="fc" id="L626">                e = e.next;</span>
            }
            V resultValue;
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">            if (e != null) {</span>
<span class="nc" id="L630">                resultValue = e.value();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                if (!onlyIfAbsent) {</span>
<span class="nc" id="L632">                    e.setValue(getValue(key, value, function), valueType, refQueue);</span>
                }
            } else {
<span class="fc" id="L635">                final V v = getValue(key, value, function);</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">                resultValue = function != null ? v : null;</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">                if (v != null) {</span>
<span class="fc" id="L638">                    ++modCount;</span>
<span class="fc" id="L639">                    tab[index] = newHashEntry(key, hash, first, v);</span>
<span class="fc" id="L640">                    count = c;</span>
                }
            }
<span class="fc" id="L643">            return resultValue;</span>
        }

        V readValueUnderLock(final HashEntry&lt;K, V&gt; e) {
<span class="nc" id="L647">            lock();</span>
            try {
<span class="nc" id="L649">                removeStale();</span>
<span class="nc" id="L650">                return e.value();</span>
            } finally {
<span class="nc" id="L652">                unlock();</span>
            }
        }

        int rehash() {
<span class="fc" id="L657">            final HashEntry&lt;K, V&gt;[] oldTable = table;</span>
<span class="fc" id="L658">            final int oldCapacity = oldTable.length;</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">            if (oldCapacity &gt;= MAXIMUM_CAPACITY) {</span>
<span class="nc" id="L660">                return 0;</span>
            }
<span class="fc" id="L662">            final HashEntry&lt;K, V&gt;[] newTable = HashEntry.newArray(oldCapacity &lt;&lt; 1);</span>
<span class="fc" id="L663">            threshold = (int) (newTable.length * loadFactor);</span>
<span class="fc" id="L664">            final int sizeMask = newTable.length - 1;</span>
<span class="fc" id="L665">            int reduce = 0;</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            for (int i = 0; i &lt; oldCapacity; i++) {</span>
<span class="fc" id="L667">                final HashEntry&lt;K, V&gt; e = oldTable[i];</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">                if (e != null) {</span>
<span class="fc" id="L669">                    final HashEntry&lt;K, V&gt; next = e.next;</span>
<span class="fc" id="L670">                    final int idx = e.hash &amp; sizeMask;</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">                    if (next == null) {</span>
<span class="fc" id="L672">                        newTable[idx] = e;</span>
                    } else {
<span class="fc" id="L674">                        HashEntry&lt;K, V&gt; lastRun = e;</span>
<span class="fc" id="L675">                        int lastIdx = idx;</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">                        for (HashEntry&lt;K, V&gt; last = next; last != null; last = last.next) {</span>
<span class="fc" id="L677">                            final int k = last.hash &amp; sizeMask;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">                            if (k != lastIdx) {</span>
<span class="fc" id="L679">                                lastIdx = k;</span>
<span class="fc" id="L680">                                lastRun = last;</span>
                            }
                        }
<span class="fc" id="L683">                        newTable[lastIdx] = lastRun;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">                        for (HashEntry&lt;K, V&gt; p = e; p != lastRun; p = p.next) {</span>
<span class="fc" id="L685">                            final K key = p.key();</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">                            if (key == null) {</span>
<span class="nc" id="L687">                                reduce++;</span>
<span class="nc" id="L688">                                continue;</span>
                            }
<span class="fc" id="L690">                            final int k = p.hash &amp; sizeMask;</span>
<span class="fc" id="L691">                            final HashEntry&lt;K, V&gt; n = newTable[k];</span>
<span class="fc" id="L692">                            newTable[k] = newHashEntry(key, p.hash, n, p.value());</span>
                        }
                    }
                }
            }
<span class="fc" id="L697">            table = newTable;</span>
<span class="fc" id="L698">            return reduce;</span>
        }

        V remove(final Object key, final int hash, final Object value, final boolean refRemove) {
<span class="fc" id="L702">            lock();</span>
            try {
<span class="fc" id="L704">                return removeInternal(key, hash, value, refRemove);</span>
            } finally {
<span class="fc" id="L706">                unlock();</span>
            }
        }

        private V removeInternal(final Object key, final int hash, final Object value, final boolean refRemove) {
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">            if (!refRemove) {</span>
<span class="fc" id="L712">                removeStale();</span>
            }
<span class="fc" id="L714">            int c = count - 1;</span>
<span class="fc" id="L715">            final HashEntry&lt;K, V&gt;[] tab = table;</span>
<span class="fc" id="L716">            final int index = hash &amp; tab.length - 1;</span>
<span class="fc" id="L717">            final HashEntry&lt;K, V&gt; first = tab[index];</span>
<span class="fc" id="L718">            HashEntry&lt;K, V&gt; e = first;</span>
<span class="pc bpc" id="L719" title="2 of 10 branches missed.">            while (e != null &amp;&amp; key != e.keyRef &amp;&amp; (refRemove || hash != e.hash || !keyEq(key, e.key()))) {</span>
<span class="fc" id="L720">                e = e.next;</span>
            }
<span class="fc" id="L722">            V oldValue = null;</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">            if (e != null) {</span>
<span class="fc" id="L724">                final V v = e.value();</span>
<span class="fc bfc" id="L725" title="All 4 branches covered.">                if (value == null || value.equals(v)) {</span>
<span class="fc" id="L726">                    oldValue = v;</span>
<span class="fc" id="L727">                    ++modCount;</span>
<span class="fc" id="L728">                    HashEntry&lt;K, V&gt; newFirst = e.next;</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                    for (HashEntry&lt;K, V&gt; p = first; p != e; p = p.next) {</span>
<span class="fc" id="L730">                        final K pKey = p.key();</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">                        if (pKey == null) {</span>
<span class="nc" id="L732">                            c--;</span>
<span class="nc" id="L733">                            continue;</span>
                        }
<span class="fc" id="L735">                        newFirst = newHashEntry(pKey, p.hash, newFirst, p.value());</span>
                    }
<span class="fc" id="L737">                    tab[index] = newFirst;</span>
<span class="fc" id="L738">                    count = c;</span>
                }
            }
<span class="fc" id="L741">            return oldValue;</span>
        }

        void removeStale() {
            KeyReference ref;
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">            while ((ref = (KeyReference) refQueue.poll()) != null) {</span>
<span class="nc" id="L747">                remove(ref.keyRef(), ref.keyHash(), null, true);</span>
            }
<span class="fc" id="L749">        }</span>

        V replace(final K key, final int hash, final V newValue) {
<span class="fc" id="L752">            lock();</span>
            try {
<span class="fc" id="L754">                return replaceInternal(key, hash, newValue);</span>
            } finally {
<span class="fc" id="L756">                unlock();</span>
            }
        }

        boolean replace(final K key, final int hash, final V oldValue, final V newValue) {
<span class="fc" id="L761">            lock();</span>
            try {
<span class="fc" id="L763">                return replaceInternal2(key, hash, oldValue, newValue);</span>
            } finally {
<span class="fc" id="L765">                unlock();</span>
            }
        }

        private V replaceInternal(final K key, final int hash, final V newValue) {
<span class="fc" id="L770">            removeStale();</span>
<span class="fc" id="L771">            HashEntry&lt;K, V&gt; e = getFirst(hash);</span>
<span class="pc bpc" id="L772" title="2 of 6 branches missed.">            while (e != null &amp;&amp; (e.hash != hash || !keyEq(key, e.key()))) {</span>
<span class="fc" id="L773">                e = e.next;</span>
            }
<span class="fc" id="L775">            V oldValue = null;</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">            if (e != null) {</span>
<span class="fc" id="L777">                oldValue = e.value();</span>
<span class="fc" id="L778">                e.setValue(newValue, valueType, refQueue);</span>
            }
<span class="fc" id="L780">            return oldValue;</span>
        }

        private boolean replaceInternal2(final K key, final int hash, final V oldValue, final V newValue) {
<span class="fc" id="L784">            removeStale();</span>
<span class="fc" id="L785">            HashEntry&lt;K, V&gt; e = getFirst(hash);</span>
<span class="pc bpc" id="L786" title="2 of 6 branches missed.">            while (e != null &amp;&amp; (e.hash != hash || !keyEq(key, e.key()))) {</span>
<span class="fc" id="L787">                e = e.next;</span>
            }
<span class="fc" id="L789">            boolean replaced = false;</span>
<span class="pc bpc" id="L790" title="2 of 4 branches missed.">            if (e != null &amp;&amp; Objects.equals(oldValue, e.value())) {</span>
<span class="fc" id="L791">                replaced = true;</span>
<span class="fc" id="L792">                e.setValue(newValue, valueType, refQueue);</span>
            }
<span class="fc" id="L794">            return replaced;</span>
        }

        void setTable(final HashEntry&lt;K, V&gt;[] newTable) {
<span class="fc" id="L798">            threshold = (int) (newTable.length * loadFactor);</span>
<span class="fc" id="L799">            table = newTable;</span>
<span class="fc" id="L800">            refQueue = new ReferenceQueue&lt;&gt;();</span>
<span class="fc" id="L801">        }</span>
    }

    private static class SimpleEntry&lt;K, V&gt; implements Entry&lt;K, V&gt; {

        private static boolean eq(final Object o1, final Object o2) {
<span class="nc" id="L807">            return Objects.equals(o1, o2);</span>
        }

        private final K key;

        private V value;

<span class="fc" id="L814">        SimpleEntry(final K key, final V value) {</span>
<span class="fc" id="L815">            this.key = key;</span>
<span class="fc" id="L816">            this.value = value;</span>
<span class="fc" id="L817">        }</span>

        @Override
        public boolean equals(final Object o) {
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (!(o instanceof Map.Entry)) {</span>
<span class="nc" id="L822">                return false;</span>
            }
<span class="nc" id="L824">            final Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;</span>
<span class="nc bnc" id="L825" title="All 4 branches missed.">            return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span>
        }

        @Override
        public K getKey() {
<span class="fc" id="L830">            return key;</span>
        }

        @Override
        public V getValue() {
<span class="fc" id="L835">            return value;</span>
        }

        @Override
        public int hashCode() {
<span class="pc bpc" id="L840" title="2 of 4 branches missed.">            return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());</span>
        }

        @Override
        public V setValue(final V value) {
<span class="nc" id="L845">            final V oldValue = this.value;</span>
<span class="nc" id="L846">            this.value = value;</span>
<span class="nc" id="L847">            return oldValue;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L852">            return key + &quot;=&quot; + value;</span>
        }
    }

    private static final class SoftKeyReference&lt;K&gt; extends SoftReference&lt;K&gt; implements KeyReference {

        private final int hash;

        SoftKeyReference(final K key, final int hash, final ReferenceQueue&lt;Object&gt; refQueue) {
<span class="fc" id="L861">            super(key, refQueue);</span>
<span class="fc" id="L862">            this.hash = hash;</span>
<span class="fc" id="L863">        }</span>

        @Override
        public int keyHash() {
<span class="nc" id="L867">            return hash;</span>
        }

        @Override
        public Object keyRef() {
<span class="nc" id="L872">            return this;</span>
        }
    }

    private static final class SoftValueReference&lt;V&gt; extends SoftReference&lt;V&gt; implements KeyReference {

        private final Object keyRef;

        private final int hash;

        SoftValueReference(final V value, final Object keyRef, final int hash, final ReferenceQueue&lt;Object&gt; refQueue) {
<span class="fc" id="L883">            super(value, refQueue);</span>
<span class="fc" id="L884">            this.keyRef = keyRef;</span>
<span class="fc" id="L885">            this.hash = hash;</span>
<span class="fc" id="L886">        }</span>

        @Override
        public int keyHash() {
<span class="nc" id="L890">            return hash;</span>
        }

        @Override
        public Object keyRef() {
<span class="nc" id="L895">            return keyRef;</span>
        }
    }

<span class="fc" id="L899">    private final class ValueIterator extends HashIterator implements Iterator&lt;V&gt;, Enumeration&lt;V&gt; {</span>

        @Override
        public V next() {
<span class="fc" id="L903">            return super.nextEntry().value();</span>
        }

        @Override
        public V nextElement() {
<span class="nc" id="L908">            return super.nextEntry().value();</span>
        }
    }

<span class="fc" id="L912">    private final class Values extends AbstractCollection&lt;V&gt; {</span>

        @Override
        public void clear() {
<span class="fc" id="L916">            ConcurrentReferenceHashMap.this.clear();</span>
<span class="fc" id="L917">        }</span>

        @Override
        public boolean contains(final Object o) {
<span class="fc" id="L921">            return ConcurrentReferenceHashMap.this.containsValue(o);</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L926">            return ConcurrentReferenceHashMap.this.isEmpty();</span>
        }

        @Override
        public Iterator&lt;V&gt; iterator() {
<span class="fc" id="L931">            return new ValueIterator();</span>
        }

        @Override
        public int size() {
<span class="fc" id="L936">            return ConcurrentReferenceHashMap.this.size();</span>
        }
    }

    private static final class WeakKeyReference&lt;K&gt; extends WeakReference&lt;K&gt; implements KeyReference {

        private final int hash;

        WeakKeyReference(final K key, final int hash, final ReferenceQueue&lt;Object&gt; refQueue) {
<span class="fc" id="L945">            super(key, refQueue);</span>
<span class="fc" id="L946">            this.hash = hash;</span>
<span class="fc" id="L947">        }</span>

        @Override
        public int keyHash() {
<span class="nc" id="L951">            return hash;</span>
        }

        @Override
        public Object keyRef() {
<span class="nc" id="L956">            return this;</span>
        }
    }

    private static final class WeakValueReference&lt;V&gt; extends WeakReference&lt;V&gt; implements KeyReference {

        private final Object keyRef;

        private final int hash;

        WeakValueReference(final V value, final Object keyRef, final int hash, final ReferenceQueue&lt;Object&gt; refQueue) {
<span class="fc" id="L967">            super(value, refQueue);</span>
<span class="fc" id="L968">            this.keyRef = keyRef;</span>
<span class="fc" id="L969">            this.hash = hash;</span>
<span class="fc" id="L970">        }</span>

        @Override
        public int keyHash() {
<span class="nc" id="L974">            return hash;</span>
        }

        @Override
        public Object keyRef() {
<span class="nc" id="L979">            return keyRef;</span>
        }
    }

    private final class WriteThroughEntry extends SimpleEntry&lt;K, V&gt; {

<span class="fc" id="L985">        private WriteThroughEntry(final K k, final V v) {</span>
<span class="fc" id="L986">            super(k, v);</span>
<span class="fc" id="L987">        }</span>

        @Override
        public V setValue(final V value) {
<span class="nc bnc" id="L991" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L992">                throw new NullPointerException();</span>
            }
<span class="nc" id="L994">            final V v = super.setValue(value);</span>
<span class="nc" id="L995">            ConcurrentReferenceHashMap.this.put(getKey(), value);</span>
<span class="nc" id="L996">            return v;</span>
        }
    }

<span class="fc" id="L1000">    static final ReferenceType DEFAULT_KEY_TYPE = ReferenceType.WEAK;</span>

<span class="fc" id="L1002">    static final ReferenceType DEFAULT_VALUE_TYPE = ReferenceType.STRONG;</span>

<span class="fc" id="L1004">    static final EnumSet&lt;Option&gt; DEFAULT_OPTIONS = null;</span>

    static final int DEFAULT_INITIAL_CAPACITY = 16;

    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    static final int DEFAULT_CONCURRENCY_LEVEL = 16;

    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    private static final int MAX_SEGMENTS = 1 &lt;&lt; 16;

    private static final int RETRIES_BEFORE_LOCK = 2;

    public static &lt;K, V&gt; Builder&lt;K, V&gt; builder() {
<span class="fc" id="L1019">        return new Builder&lt;&gt;();</span>
    }

    private static int hash(int h) {
<span class="fc" id="L1023">        h += h &lt;&lt; 15 ^ 0xffffcd7d;</span>
<span class="fc" id="L1024">        h ^= h &gt;&gt;&gt; 10;</span>
<span class="fc" id="L1025">        h += h &lt;&lt; 3;</span>
<span class="fc" id="L1026">        h ^= h &gt;&gt;&gt; 6;</span>
<span class="fc" id="L1027">        h += (h &lt;&lt; 2) + (h &lt;&lt; 14);</span>
<span class="fc" id="L1028">        return h ^ h &gt;&gt;&gt; 16;</span>
    }

    private final int segmentMask;

    private final int segmentShift;

    private final Segment&lt;K, V&gt;[] segments;

    private final boolean identityComparisons;

    private transient Set&lt;K&gt; keySet;

    private transient Set&lt;Entry&lt;K, V&gt;&gt; entrySet;

    private transient Collection&lt;V&gt; values;

<span class="fc" id="L1045">    private ConcurrentReferenceHashMap(int initialCapacity, final float loadFactor, int concurrencyLevel, final ReferenceType keyType, final ReferenceType valueType, final EnumSet&lt;Option&gt; options) {</span>
<span class="pc bpc" id="L1046" title="3 of 6 branches missed.">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) {</span>
<span class="nc" id="L1047">            throw new IllegalArgumentException();</span>
        }
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">        if (concurrencyLevel &gt; MAX_SEGMENTS) {</span>
<span class="nc" id="L1050">            concurrencyLevel = MAX_SEGMENTS;</span>
        }
<span class="fc" id="L1052">        int sshift = 0;</span>
<span class="fc" id="L1053">        int ssize = 1;</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        while (ssize &lt; concurrencyLevel) {</span>
<span class="fc" id="L1055">            ++sshift;</span>
<span class="fc" id="L1056">            ssize &lt;&lt;= 1;</span>
        }
<span class="fc" id="L1058">        segmentShift = 32 - sshift;</span>
<span class="fc" id="L1059">        segmentMask = ssize - 1;</span>
<span class="fc" id="L1060">        this.segments = Segment.newArray(ssize);</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">        if (initialCapacity &gt; MAXIMUM_CAPACITY) {</span>
<span class="nc" id="L1062">            initialCapacity = MAXIMUM_CAPACITY;</span>
        }
<span class="fc" id="L1064">        int c = initialCapacity / ssize;</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if (c * ssize &lt; initialCapacity) {</span>
<span class="fc" id="L1066">            ++c;</span>
        }
<span class="fc" id="L1068">        int cap = 1;</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        while (cap &lt; c) {</span>
<span class="fc" id="L1070">            cap &lt;&lt;= 1;</span>
        }
<span class="pc bpc" id="L1072" title="1 of 4 branches missed.">        identityComparisons = options != null &amp;&amp; options.contains(Option.IDENTITY_COMPARISONS);</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        for (int i = 0; i &lt; this.segments.length; ++i) {</span>
<span class="fc" id="L1074">            this.segments[i] = new Segment&lt;&gt;(cap, loadFactor, keyType, valueType, identityComparisons);</span>
        }
<span class="fc" id="L1076">    }</span>

    @Override
    public void clear() {
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="fc" id="L1081">            segment.clear();</span>
        }
<span class="fc" id="L1083">    }</span>

    @Override
    public V compute(final K key, final BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="nc" id="L1087">        Objects.requireNonNull(key);</span>
<span class="nc" id="L1088">        Objects.requireNonNull(remappingFunction);</span>
<span class="nc" id="L1089">        final int hash = hashOf(key);</span>
<span class="nc" id="L1090">        final Segment&lt;K, V&gt; segment = segmentFor(hash);</span>
<span class="nc" id="L1091">        return segment.apply(key, hash, remappingFunction);</span>
    }

    @Override
    public V computeIfAbsent(final K key, final Function&lt;? super K, ? extends V&gt; mappingFunction) {
<span class="fc" id="L1096">        Objects.requireNonNull(key);</span>
<span class="fc" id="L1097">        Objects.requireNonNull(mappingFunction);</span>
<span class="fc" id="L1098">        final int hash = hashOf(key);</span>
<span class="fc" id="L1099">        final Segment&lt;K, V&gt; segment = segmentFor(hash);</span>
<span class="fc" id="L1100">        final V v = segment.get(key, hash);</span>
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">        return v == null ? segment.put(key, hash, null, mappingFunction, true) : v;</span>
    }

    @Override
    public V computeIfPresent(final K key, final BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
<span class="fc" id="L1106">        Objects.requireNonNull(key);</span>
<span class="fc" id="L1107">        Objects.requireNonNull(remappingFunction);</span>
<span class="fc" id="L1108">        final int hash = hashOf(key);</span>
<span class="fc" id="L1109">        final Segment&lt;K, V&gt; segment = segmentFor(hash);</span>
<span class="fc" id="L1110">        final V v = segment.get(key, hash);</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">        if (v == null) {</span>
<span class="nc" id="L1112">            return null;</span>
        }
<span class="fc" id="L1114">        return segmentFor(hash).applyIfPresent(key, hash, remappingFunction);</span>
    }

    @Override
    public boolean containsKey(final Object key) {
<span class="fc" id="L1119">        final int hash = hashOf(key);</span>
<span class="fc" id="L1120">        return segmentFor(hash).containsKey(key, hash);</span>
    }

    @Override
    public boolean containsValue(final Object value) {
<span class="fc bfc" id="L1125" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L1126">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1128">        final Segment&lt;K, V&gt;[] segments = this.segments;</span>
<span class="fc" id="L1129">        final int[] mc = new int[segments.length];</span>
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">        for (int k = 0; k &lt; RETRIES_BEFORE_LOCK; ++k) {</span>
<span class="fc" id="L1131">            int mcsum = 0;</span>
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">            for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L1133">                mcsum += mc[i] = segments[i].modCount;</span>
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">                if (segments[i].containsValue(value)) {</span>
<span class="fc" id="L1135">                    return true;</span>
                }
            }
<span class="nc" id="L1138">            boolean cleanSweep = true;</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            if (mcsum != 0) {</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">                for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                    if (mc[i] != segments[i].modCount) {</span>
<span class="nc" id="L1142">                        cleanSweep = false;</span>
<span class="nc" id="L1143">                        break;</span>
                    }
                }
            }
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            if (cleanSweep) {</span>
<span class="nc" id="L1148">                return false;</span>
            }
        }
<span class="nc bnc" id="L1151" title="All 2 branches missed.">        for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="nc" id="L1152">            segment.lock();</span>
        }
<span class="nc" id="L1154">        boolean found = false;</span>
        try {
<span class="nc bnc" id="L1156" title="All 2 branches missed.">            for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">                if (segment.containsValue(value)) {</span>
<span class="nc" id="L1158">                    found = true;</span>
<span class="nc" id="L1159">                    break;</span>
                }
            }
        } finally {
<span class="nc bnc" id="L1163" title="All 2 branches missed.">            for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="nc" id="L1164">                segment.unlock();</span>
            }
        }
<span class="nc" id="L1167">        return found;</span>
    }

    @Override
    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
<span class="fc" id="L1172">        final Set&lt;Entry&lt;K, V&gt;&gt; es = entrySet;</span>
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        return es != null ? es : (entrySet = new EntrySet(false));</span>
    }

    @Override
    public V get(final Object key) {
<span class="fc" id="L1178">        final int hash = hashOf(key);</span>
<span class="fc" id="L1179">        return segmentFor(hash).get(key, hash);</span>
    }

    private int hashOf(final Object key) {
<span class="fc bfc" id="L1183" title="All 2 branches covered.">        return hash(identityComparisons ? System.identityHashCode(key) : key.hashCode());</span>
    }

    @Override
    public boolean isEmpty() {
<span class="fc" id="L1188">        final Segment&lt;K, V&gt;[] segments = this.segments;</span>
<span class="fc" id="L1189">        final int[] mc = new int[segments.length];</span>
<span class="fc" id="L1190">        int mcsum = 0;</span>
<span class="fc bfc" id="L1191" title="All 2 branches covered.">        for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc bfc" id="L1192" title="All 2 branches covered.">            if (segments[i].count != 0) {</span>
<span class="fc" id="L1193">                return false;</span>
            }
<span class="fc" id="L1195">            mcsum += mc[i] = segments[i].modCount;</span>
        }
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        if (mcsum != 0) {</span>
<span class="fc bfc" id="L1198" title="All 2 branches covered.">            for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="pc bpc" id="L1199" title="2 of 4 branches missed.">                if (segments[i].count != 0 || mc[i] != segments[i].modCount) {</span>
<span class="nc" id="L1200">                    return false;</span>
                }
            }
        }
<span class="fc" id="L1204">        return true;</span>
    }

    @Override
    public Set&lt;K&gt; keySet() {
<span class="fc" id="L1209">        final Set&lt;K&gt; ks = keySet;</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">        return ks != null ? ks : (keySet = new KeySet());</span>
    }

    public void purgeStaleEntries() {
<span class="nc bnc" id="L1214" title="All 2 branches missed.">        for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="nc" id="L1215">            segment.removeStale();</span>
        }
<span class="nc" id="L1217">    }</span>

    @Override
    public V put(final K key, final V value) {
<span class="fc bfc" id="L1221" title="All 4 branches covered.">        if (key == null || value == null) {</span>
<span class="fc" id="L1222">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1224">        final int hash = hashOf(key);</span>
<span class="fc" id="L1225">        return segmentFor(hash).put(key, hash, value, null, false);</span>
    }

    @Override
    public void putAll(final Map&lt;? extends K, ? extends V&gt; m) {
<span class="fc bfc" id="L1230" title="All 2 branches covered.">        for (final Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</span>
<span class="fc" id="L1231">            put(e.getKey(), e.getValue());</span>
<span class="fc" id="L1232">        }</span>
<span class="fc" id="L1233">    }</span>

    @Override
    public V putIfAbsent(final K key, final V value) {
<span class="pc bpc" id="L1237" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L1238">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1240">        final int hash = hashOf(key);</span>
<span class="fc" id="L1241">        return segmentFor(hash).put(key, hash, value, null, true);</span>
    }

    @Override
    public V remove(final Object key) {
<span class="fc" id="L1246">        final int hash = hashOf(key);</span>
<span class="fc" id="L1247">        return segmentFor(hash).remove(key, hash, null, false);</span>
    }

    @Override
    public boolean remove(final Object key, final Object value) {
<span class="fc" id="L1252">        final int hash = hashOf(key);</span>
<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L1254">            return false;</span>
        }
<span class="fc bfc" id="L1256" title="All 2 branches covered.">        return segmentFor(hash).remove(key, hash, value, false) != null;</span>
    }

    @Override
    public V replace(final K key, final V value) {
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L1262">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1264">        final int hash = hashOf(key);</span>
<span class="fc" id="L1265">        return segmentFor(hash).replace(key, hash, value);</span>
    }

    @Override
    public boolean replace(final K key, final V oldValue, final V newValue) {
<span class="pc bpc" id="L1270" title="2 of 4 branches missed.">        if (oldValue == null || newValue == null) {</span>
<span class="nc" id="L1271">            throw new NullPointerException();</span>
        }
<span class="fc" id="L1273">        final int hash = hashOf(key);</span>
<span class="fc" id="L1274">        return segmentFor(hash).replace(key, hash, oldValue, newValue);</span>
    }

    private Segment&lt;K, V&gt; segmentFor(final int hash) {
<span class="fc" id="L1278">        return segments[hash &gt;&gt;&gt; segmentShift &amp; segmentMask];</span>
    }

    @Override
    public int size() {
<span class="fc" id="L1283">        final Segment&lt;K, V&gt;[] segments = this.segments;</span>
<span class="fc" id="L1284">        long sum = 0;</span>
<span class="fc" id="L1285">        long check = 0;</span>
<span class="fc" id="L1286">        final int[] mc = new int[segments.length];</span>
<span class="pc bpc" id="L1287" title="1 of 2 branches missed.">        for (int k = 0; k &lt; RETRIES_BEFORE_LOCK; ++k) {</span>
<span class="fc" id="L1288">            check = 0;</span>
<span class="fc" id="L1289">            sum = 0;</span>
<span class="fc" id="L1290">            int mcsum = 0;</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">            for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L1292">                sum += segments[i].count;</span>
<span class="fc" id="L1293">                mcsum += mc[i] = segments[i].modCount;</span>
            }
<span class="fc bfc" id="L1295" title="All 2 branches covered.">            if (mcsum != 0) {</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">                for (int i = 0; i &lt; segments.length; ++i) {</span>
<span class="fc" id="L1297">                    check += segments[i].count;</span>
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">                    if (mc[i] != segments[i].modCount) {</span>
<span class="nc" id="L1299">                        check = -1;</span>
<span class="nc" id="L1300">                        break;</span>
                    }
                }
            }
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">            if (check == sum) {</span>
<span class="fc" id="L1305">                break;</span>
            }
        }
<span class="pc bpc" id="L1308" title="1 of 2 branches missed.">        if (check != sum) {</span>
<span class="nc" id="L1309">            sum = 0;</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">            for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="nc" id="L1311">                segment.lock();</span>
            }
<span class="nc bnc" id="L1313" title="All 2 branches missed.">            for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="nc" id="L1314">                sum += segment.count;</span>
            }
<span class="nc bnc" id="L1316" title="All 2 branches missed.">            for (final Segment&lt;K, V&gt; segment : segments) {</span>
<span class="nc" id="L1317">                segment.unlock();</span>
            }
        }
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">        return sum &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) sum;</span>
    }

    @Override
    public Collection&lt;V&gt; values() {
<span class="fc" id="L1325">        final Collection&lt;V&gt; vs = values;</span>
<span class="pc bpc" id="L1326" title="1 of 2 branches missed.">        return vs != null ? vs : (values = new Values());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>