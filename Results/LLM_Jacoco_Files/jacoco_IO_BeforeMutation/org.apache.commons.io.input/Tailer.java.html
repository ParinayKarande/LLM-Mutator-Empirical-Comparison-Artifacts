<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tailer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons IO</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.io.input</a> &gt; <span class="el_source">Tailer.java</span></div><h1>Tailer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.io.input;

import static org.apache.commons.io.IOUtils.CR;
import static org.apache.commons.io.IOUtils.EOF;
import static org.apache.commons.io.IOUtils.LF;

import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.attribute.FileTime;
import java.time.Duration;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.apache.commons.io.IOUtils;
import org.apache.commons.io.ThreadUtils;
import org.apache.commons.io.build.AbstractOrigin;
import org.apache.commons.io.build.AbstractStreamBuilder;
import org.apache.commons.io.file.PathUtils;
import org.apache.commons.io.file.attribute.FileTimes;

/**
 * Simple implementation of the UNIX &quot;tail -f&quot; functionality.
 * &lt;p&gt;
 * To build an instance, use {@link Builder}.
 * &lt;/p&gt;
 * &lt;h2&gt;1. Create a TailerListener implementation&lt;/h2&gt;
 * &lt;p&gt;
 * First you need to create a {@link TailerListener} implementation; ({@link TailerListenerAdapter} is provided for
 * convenience so that you don't have to implement every method).
 * &lt;/p&gt;
 * &lt;p&gt;
 * For example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * public class MyTailerListener extends TailerListenerAdapter {
 *     public void handle(String line) {
 *         System.out.println(line);
 *     }
 * }
 * &lt;/pre&gt;
 * &lt;h2&gt;2. Using a Tailer&lt;/h2&gt;
 * &lt;p&gt;
 * You can create and use a Tailer in one of three ways:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Using a {@link Builder}&lt;/li&gt;
 * &lt;li&gt;Using an {@link java.util.concurrent.Executor}&lt;/li&gt;
 * &lt;li&gt;Using a {@link Thread}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * An example of each is shown below.
 * &lt;/p&gt;
 * &lt;h3&gt;2.1 Using a Builder&lt;/h3&gt;
 * &lt;pre&gt;
 * TailerListener listener = new MyTailerListener();
 * Tailer tailer = Tailer.builder()
 *   .setFile(file)
 *   .setTailerListener(listener)
 *   .setDelayDuration(delay)
 *   .get();
 * &lt;/pre&gt;
 * &lt;h3&gt;2.2 Using an Executor&lt;/h3&gt;
 * &lt;pre&gt;
 * TailerListener listener = new MyTailerListener();
 * Tailer tailer = new Tailer(file, listener, delay);
 *
 * // stupid executor impl. for demo purposes
 * Executor executor = new Executor() {
 *     public void execute(Runnable command) {
 *         command.run();
 *     }
 * };
 *
 * executor.execute(tailer);
 * &lt;/pre&gt;
 * &lt;h3&gt;2.3 Using a Thread&lt;/h3&gt;
 * &lt;pre&gt;
 * TailerListener listener = new MyTailerListener();
 * Tailer tailer = new Tailer(file, listener, delay);
 * Thread thread = new Thread(tailer);
 * thread.setDaemon(true); // optional
 * thread.start();
 * &lt;/pre&gt;
 * &lt;h2&gt;3. Stopping a Tailer&lt;/h2&gt;
 * &lt;p&gt;
 * Remember to stop the tailer when you have done with it:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * tailer.stop();
 * &lt;/pre&gt;
 * &lt;h2&gt;4. Interrupting a Tailer&lt;/h2&gt;
 * &lt;p&gt;
 * You can interrupt the thread a tailer is running on by calling {@link Thread#interrupt()}.
 * &lt;/p&gt;
 * &lt;pre&gt;
 * thread.interrupt();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * If you interrupt a tailer, the tailer listener is called with the {@link InterruptedException}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The file is read using the default Charset; this can be overridden if necessary.
 * &lt;/p&gt;
 *
 * @see Builder
 * @see TailerListener
 * @see TailerListenerAdapter
 * @since 2.0
 * @since 2.5 Updated behavior and documentation for {@link Thread#interrupt()}.
 * @since 2.12.0 Add {@link Tailable} and {@link RandomAccessResourceBridge} interfaces to tail of files accessed using
 *        alternative libraries such as jCIFS or &lt;a href=&quot;https://commons.apache.org/proper/commons-vfs/&quot;&gt;Apache Commons
 *        VFS&lt;/a&gt;.
 */
public class Tailer implements Runnable, AutoCloseable {

    // @formatter:off
    /**
     * Builds a new {@link Tailer}.
     *
     * &lt;p&gt;
     * For example:
     * &lt;/p&gt;
     * &lt;pre&gt;{@code
     * Tailer t = Tailer.builder()
     *   .setPath(path)
     *   .setCharset(StandardCharsets.UTF_8)
     *   .setDelayDuration(Duration.ofSeconds(1))
     *   .setExecutorService(Executors.newSingleThreadExecutor(Builder::newDaemonThread))
     *   .setReOpen(false)
     *   .setStartThread(true)
     *   .setTailable(tailable)
     *   .setTailerListener(tailerListener)
     *   .setTailFromEnd(false)
     *   .get();}
     * &lt;/pre&gt;
     *
     * @see #get()
     * @since 2.12.0
     */
    // @formatter:on
<span class="fc" id="L167">    public static class Builder extends AbstractStreamBuilder&lt;Tailer, Builder&gt; {</span>

<span class="fc" id="L169">        private static final Duration DEFAULT_DELAY_DURATION = Duration.ofMillis(DEFAULT_DELAY_MILLIS);</span>

        /**
         * Creates a new daemon thread.
         *
         * @param runnable the thread's runnable.
         * @return a new daemon thread.
         */
        private static Thread newDaemonThread(final Runnable runnable) {
<span class="fc" id="L178">            final Thread thread = new Thread(runnable, &quot;commons-io-tailer&quot;);</span>
<span class="fc" id="L179">            thread.setDaemon(true);</span>
<span class="fc" id="L180">            return thread;</span>
        }

        private Tailable tailable;
        private TailerListener tailerListener;
<span class="fc" id="L185">        private Duration delayDuration = DEFAULT_DELAY_DURATION;</span>
        private boolean tailFromEnd;
        private boolean reOpen;
<span class="fc" id="L188">        private boolean startThread = true;</span>
<span class="fc" id="L189">        private ExecutorService executorService = Executors.newSingleThreadExecutor(Builder::newDaemonThread);</span>

        /**
         * Builds a new {@link Tailer}.
         *
         * &lt;p&gt;
         * This builder use the following aspects:
         * &lt;/p&gt;
         * &lt;ul&gt;
         * &lt;li&gt;{@link #getBufferSize()}&lt;/li&gt;
         * &lt;li&gt;{@link #getCharset()}&lt;/li&gt;
         * &lt;li&gt;{@link Tailable}&lt;/li&gt;
         * &lt;li&gt;{@link TailerListener}&lt;/li&gt;
         * &lt;li&gt;delayDuration&lt;/li&gt;
         * &lt;li&gt;tailFromEnd&lt;/li&gt;
         * &lt;li&gt;reOpen&lt;/li&gt;
         * &lt;/ul&gt;
         *
         * @return a new instance.
         */
        @Override
        public Tailer get() {
<span class="fc" id="L211">            final Tailer tailer = new Tailer(tailable, getCharset(), tailerListener, delayDuration, tailFromEnd, reOpen, getBufferSize());</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (startThread) {</span>
<span class="fc" id="L213">                executorService.submit(tailer);</span>
            }
<span class="fc" id="L215">            return tailer;</span>
        }

        /**
         * Sets the delay duration. null resets to the default delay of one second.
         *
         * @param delayDuration the delay between checks of the file for new content.
         * @return {@code this} instance.
         */
        public Builder setDelayDuration(final Duration delayDuration) {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            this.delayDuration = delayDuration != null ? delayDuration : DEFAULT_DELAY_DURATION;</span>
<span class="fc" id="L226">            return this;</span>
        }

        /**
         * Sets the executor service to use when startThread is true.
         *
         * @param executorService the executor service to use when startThread is true.
         * @return {@code this} instance.
         */
        public Builder setExecutorService(final ExecutorService executorService) {
<span class="fc" id="L236">            this.executorService = Objects.requireNonNull(executorService, &quot;executorService&quot;);</span>
<span class="fc" id="L237">            return this;</span>
        }

        /**
         * Sets the origin.
         *
         * @throws UnsupportedOperationException if the origin cannot be converted to a Path.
         */
        @Override
        protected Builder setOrigin(final AbstractOrigin&lt;?, ?&gt; origin) {
<span class="fc" id="L247">            setTailable(new TailablePath(origin.getPath()));</span>
<span class="fc" id="L248">            return super.setOrigin(origin);</span>
        }

        /**
         * Sets the re-open behavior.
         *
         * @param reOpen whether to close/reopen the file between chunks
         * @return {@code this} instance.
         */
        public Builder setReOpen(final boolean reOpen) {
<span class="fc" id="L258">            this.reOpen = reOpen;</span>
<span class="fc" id="L259">            return this;</span>
        }

        /**
         * Sets the daemon thread startup behavior.
         *
         * @param startThread whether to create a daemon thread automatically.
         * @return {@code this} instance.
         */
        public Builder setStartThread(final boolean startThread) {
<span class="nc" id="L269">            this.startThread = startThread;</span>
<span class="nc" id="L270">            return this;</span>
        }

        /**
         * Sets the tailable.
         *
         * @param tailable the tailable.
         * @return {@code this} instance.
         */
        public Builder setTailable(final Tailable tailable) {
<span class="fc" id="L280">            this.tailable = Objects.requireNonNull(tailable, &quot;tailable&quot;);</span>
<span class="fc" id="L281">            return this;</span>
        }

        /**
         * Sets the listener.
         *
         * @param tailerListener the listener.
         * @return {@code this} instance.
         */
        public Builder setTailerListener(final TailerListener tailerListener) {
<span class="fc" id="L291">            this.tailerListener = Objects.requireNonNull(tailerListener, &quot;tailerListener&quot;);</span>
<span class="fc" id="L292">            return this;</span>
        }

        /**
         * Sets the tail start behavior.
         *
         * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
         * @return {@code this} instance.
         */
        public Builder setTailFromEnd(final boolean end) {
<span class="fc" id="L302">            this.tailFromEnd = end;</span>
<span class="fc" id="L303">            return this;</span>
        }
    }

    /**
     * Bridges random access to a {@link RandomAccessFile}.
     */
    private static final class RandomAccessFileBridge implements RandomAccessResourceBridge {

        private final RandomAccessFile randomAccessFile;

<span class="fc" id="L314">        private RandomAccessFileBridge(final File file, final String mode) throws FileNotFoundException {</span>
<span class="fc" id="L315">            randomAccessFile = new RandomAccessFile(file, mode);</span>
<span class="fc" id="L316">        }</span>

        @Override
        public void close() throws IOException {
<span class="fc" id="L320">            randomAccessFile.close();</span>
<span class="fc" id="L321">        }</span>

        @Override
        public long getPointer() throws IOException {
<span class="fc" id="L325">            return randomAccessFile.getFilePointer();</span>
        }

        @Override
        public int read(final byte[] b) throws IOException {
<span class="fc" id="L330">            return randomAccessFile.read(b);</span>
        }

        @Override
        public void seek(final long position) throws IOException {
<span class="fc" id="L335">            randomAccessFile.seek(position);</span>
<span class="fc" id="L336">        }</span>

    }

    /**
     * Bridges access to a resource for random access, normally a file. Allows substitution of remote files for example
     * using jCIFS.
     *
     * @since 2.12.0
     */
    public interface RandomAccessResourceBridge extends Closeable {

        /**
         * Gets the current offset in this tailable.
         *
         * @return the offset from the beginning of the tailable, in bytes, at which the next read or write occurs.
         * @throws IOException if an I/O error occurs.
         */
        long getPointer() throws IOException;

        /**
         * Reads up to {@code b.length} bytes of data from this tailable into an array of bytes. This method blocks until at
         * least one byte of input is available.
         *
         * @param b the buffer into which the data is read.
         * @return the total number of bytes read into the buffer, or {@code -1} if there is no more data because the end of
         *         this tailable has been reached.
         * @throws IOException If the first byte cannot be read for any reason other than end of tailable, or if the random
         *         access tailable has been closed, or if some other I/O error occurs.
         */
        int read(final byte[] b) throws IOException;

        /**
         * Sets the file-pointer offset, measured from the beginning of this tailable, at which the next read or write occurs.
         * The offset may be set beyond the end of the tailable. Setting the offset beyond the end of the tailable does not
         * change the tailable length. The tailable length will change only by writing after the offset has been set beyond the
         * end of the tailable.
         *
         * @param pos the offset position, measured in bytes from the beginning of the tailable, at which to set the tailable
         *        pointer.
         * @throws IOException if {@code pos} is less than {@code 0} or if an I/O error occurs.
         */
        void seek(final long pos) throws IOException;
    }

    /**
     * A tailable resource like a file.
     *
     * @since 2.12.0
     */
    public interface Tailable {

        /**
         * Creates a random access file stream to read.
         *
         * @param mode the access mode, by default this is for {@link RandomAccessFile}.
         * @return a random access file stream to read.
         * @throws FileNotFoundException if the tailable object does not exist.
         */
        RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException;

        /**
         * Tests if this tailable is newer than the specified {@link FileTime}.
         *
         * @param fileTime the file time reference.
         * @return true if the {@link File} exists and has been modified after the given {@link FileTime}.
         * @throws IOException if an I/O error occurs.
         */
        boolean isNewer(final FileTime fileTime) throws IOException;

        /**
         * Gets the last modification {@link FileTime}.
         *
         * @return See {@link java.nio.file.Files#getLastModifiedTime(Path, LinkOption...)}.
         * @throws IOException if an I/O error occurs.
         */
        FileTime lastModifiedFileTime() throws IOException;

        /**
         * Gets the size of this tailable.
         *
         * @return The size, in bytes, of this tailable, or {@code 0} if the file does not exist. Some operating systems may
         *         return {@code 0} for path names denoting system-dependent entities such as devices or pipes.
         * @throws IOException if an I/O error occurs.
         */
        long size() throws IOException;
    }

    /**
     * A tailable for a file {@link Path}.
     */
    private static final class TailablePath implements Tailable {

        private final Path path;
        private final LinkOption[] linkOptions;

<span class="fc" id="L432">        private TailablePath(final Path path, final LinkOption... linkOptions) {</span>
<span class="fc" id="L433">            this.path = Objects.requireNonNull(path, &quot;path&quot;);</span>
<span class="fc" id="L434">            this.linkOptions = linkOptions;</span>
<span class="fc" id="L435">        }</span>

        Path getPath() {
<span class="nc" id="L438">            return path;</span>
        }

        @Override
        public RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException {
<span class="fc" id="L443">            return new RandomAccessFileBridge(path.toFile(), mode);</span>
        }

        @Override
        public boolean isNewer(final FileTime fileTime) throws IOException {
<span class="fc" id="L448">            return PathUtils.isNewer(path, fileTime, linkOptions);</span>
        }

        @Override
        public FileTime lastModifiedFileTime() throws IOException {
<span class="fc" id="L453">            return Files.getLastModifiedTime(path, linkOptions);</span>
        }

        @Override
        public long size() throws IOException {
<span class="fc" id="L458">            return Files.size(path);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L463">            return &quot;TailablePath [file=&quot; + path + &quot;, linkOptions=&quot; + Arrays.toString(linkOptions) + &quot;]&quot;;</span>
        }
    }

    private static final int DEFAULT_DELAY_MILLIS = 1000;

    private static final String RAF_READ_ONLY_MODE = &quot;r&quot;;

    // The default charset used for reading files
<span class="fc" id="L472">    private static final Charset DEFAULT_CHARSET = Charset.defaultCharset();</span>

    /**
     * Constructs a new {@link Builder}.
     *
     * @return Creates a new {@link Builder}.
     * @since 2.12.0
     */
    public static Builder builder() {
<span class="fc" id="L481">        return new Builder();</span>
    }

    /**
     * Creates and starts a Tailer for the given file.
     *
     * @param file the file to follow.
     * @param charset the character set to use for reading the file.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen whether to close/reopen the file between chunks.
     * @param bufferSize buffer size.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public static Tailer create(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end,
        final boolean reOpen, final int bufferSize) {
        //@formatter:off
<span class="fc" id="L501">        return builder()</span>
<span class="fc" id="L502">                .setFile(file)</span>
<span class="fc" id="L503">                .setTailerListener(listener)</span>
<span class="fc" id="L504">                .setCharset(charset)</span>
<span class="fc" id="L505">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L506">                .setTailFromEnd(end)</span>
<span class="fc" id="L507">                .setReOpen(reOpen)</span>
<span class="fc" id="L508">                .setBufferSize(bufferSize)</span>
<span class="fc" id="L509">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file, starting at the beginning of the file with the default delay of 1.0s
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener) {
        //@formatter:off
<span class="fc" id="L524">        return builder()</span>
<span class="fc" id="L525">                .setFile(file)</span>
<span class="fc" id="L526">                .setTailerListener(listener)</span>
<span class="fc" id="L527">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file, starting at the beginning of the file
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis) {
        //@formatter:off
<span class="fc" id="L543">        return builder()</span>
<span class="fc" id="L544">                .setFile(file)</span>
<span class="fc" id="L545">                .setTailerListener(listener)</span>
<span class="fc" id="L546">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L547">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file with default buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end) {
        //@formatter:off
<span class="fc" id="L564">        return builder()</span>
<span class="fc" id="L565">                .setFile(file)</span>
<span class="fc" id="L566">                .setTailerListener(listener)</span>
<span class="fc" id="L567">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L568">                .setTailFromEnd(end)</span>
<span class="fc" id="L569">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file with default buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen whether to close/reopen the file between chunks.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {
        //@formatter:off
<span class="fc" id="L587">        return builder()</span>
<span class="fc" id="L588">                .setFile(file)</span>
<span class="fc" id="L589">                .setTailerListener(listener)</span>
<span class="fc" id="L590">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L591">                .setTailFromEnd(end)</span>
<span class="fc" id="L592">                .setReOpen(reOpen)</span>
<span class="fc" id="L593">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen whether to close/reopen the file between chunks.
     * @param bufferSize buffer size.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,
        final int bufferSize) {
        //@formatter:off
<span class="fc" id="L613">        return builder()</span>
<span class="fc" id="L614">                .setFile(file)</span>
<span class="fc" id="L615">                .setTailerListener(listener)</span>
<span class="fc" id="L616">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L617">                .setTailFromEnd(end)</span>
<span class="fc" id="L618">                .setReOpen(reOpen)</span>
<span class="fc" id="L619">                .setBufferSize(bufferSize)</span>
<span class="fc" id="L620">                .get();</span>
        //@formatter:on
    }

    /**
     * Creates and starts a Tailer for the given file.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param bufferSize buffer size.
     * @return The new tailer.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {
        //@formatter:off
<span class="fc" id="L638">        return builder()</span>
<span class="fc" id="L639">                .setFile(file)</span>
<span class="fc" id="L640">                .setTailerListener(listener)</span>
<span class="fc" id="L641">                .setDelayDuration(Duration.ofMillis(delayMillis))</span>
<span class="fc" id="L642">                .setTailFromEnd(end)</span>
<span class="fc" id="L643">                .setBufferSize(bufferSize)</span>
<span class="fc" id="L644">                .get();</span>
        //@formatter:on
    }

    /**
     * Buffer on top of RandomAccessResourceBridge.
     */
    private final byte[] inbuf;

    /**
     * The file which will be tailed.
     */
    private final Tailable tailable;

    /**
     * The character set that will be used to read the file.
     */
    private final Charset charset;

    /**
     * The amount of time to wait for the file to be updated.
     */
    private final Duration delayDuration;

    /**
     * Whether to tail from the end or start of file
     */
    private final boolean tailAtEnd;

    /**
     * The listener to notify of events when tailing.
     */
    private final TailerListener listener;

    /**
     * Whether to close and reopen the file whilst waiting for more input.
     */
    private final boolean reOpen;

    /**
     * The tailer will run as long as this value is true.
     */
<span class="fc" id="L686">    private volatile boolean run = true;</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param file the file to follow.
     * @param charset the Charset to be used for reading the file
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @param bufSize Buffer size
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public Tailer(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,
        final int bufSize) {
<span class="fc" id="L703">        this(new TailablePath(file.toPath()), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize);</span>
<span class="fc" id="L704">    }</span>

    /**
     * Creates a Tailer for the given file, starting from the beginning, with the default delay of 1.0s.
     *
     * @param file The file to follow.
     * @param listener the TailerListener to use.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener) {
<span class="fc" id="L715">        this(file, listener, DEFAULT_DELAY_MILLIS);</span>
<span class="fc" id="L716">    }</span>

    /**
     * Creates a Tailer for the given file, starting from the beginning.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis) {
<span class="fc" id="L728">        this(file, listener, delayMillis, false);</span>
<span class="fc" id="L729">    }</span>

    /**
     * Creates a Tailer for the given file, with a delay other than the default 1.0s.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end) {
<span class="fc" id="L742">        this(file, listener, delayMillis, end, IOUtils.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L743">    }</span>

    /**
     * Creates a Tailer for the given file, with a delay other than the default 1.0s.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {
<span class="fc" id="L757">        this(file, listener, delayMillis, end, reOpen, IOUtils.DEFAULT_BUFFER_SIZE);</span>
<span class="fc" id="L758">    }</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @param bufferSize Buffer size
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {
<span class="fc" id="L773">        this(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufferSize);</span>
<span class="fc" id="L774">    }</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param file the file to follow.
     * @param listener the TailerListener to use.
     * @param delayMillis the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param bufferSize Buffer size
     * @deprecated Use {@link #builder()}, {@link Builder}, and {@link Builder#get()}.
     */
    @Deprecated
    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {
<span class="fc" id="L788">        this(file, listener, delayMillis, end, false, bufferSize);</span>
<span class="fc" id="L789">    }</span>

    /**
     * Creates a Tailer for the given file, with a specified buffer size.
     *
     * @param tailable the file to follow.
     * @param charset the Charset to be used for reading the file
     * @param listener the TailerListener to use.
     * @param delayDuration the delay between checks of the file for new content in milliseconds.
     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.
     * @param reOpen if true, close and reopen the file between reading chunks
     * @param bufferSize Buffer size
     */
    private Tailer(final Tailable tailable, final Charset charset, final TailerListener listener, final Duration delayDuration, final boolean end,
<span class="fc" id="L803">        final boolean reOpen, final int bufferSize) {</span>
<span class="fc" id="L804">        this.tailable = Objects.requireNonNull(tailable, &quot;tailable&quot;);</span>
<span class="fc" id="L805">        this.listener = Objects.requireNonNull(listener, &quot;listener&quot;);</span>
<span class="fc" id="L806">        this.delayDuration = delayDuration;</span>
<span class="fc" id="L807">        this.tailAtEnd = end;</span>
<span class="fc" id="L808">        this.inbuf = IOUtils.byteArray(bufferSize);</span>

        // Save and prepare the listener
<span class="fc" id="L811">        listener.init(this);</span>
<span class="fc" id="L812">        this.reOpen = reOpen;</span>
<span class="fc" id="L813">        this.charset = charset;</span>
<span class="fc" id="L814">    }</span>

    /**
     * Requests the tailer to complete its current loop and return.
     */
    @Override
    public void close() {
<span class="fc" id="L821">        this.run = false;</span>
<span class="fc" id="L822">    }</span>

    /**
     * Gets the delay in milliseconds.
     *
     * @return the delay in milliseconds.
     * @deprecated Use {@link #getDelayDuration()}.
     */
    @Deprecated
    public long getDelay() {
<span class="nc" id="L832">        return delayDuration.toMillis();</span>
    }

    /**
     * Gets the delay Duration.
     *
     * @return the delay Duration.
     * @since 2.12.0
     */
    public Duration getDelayDuration() {
<span class="nc" id="L842">        return delayDuration;</span>
    }

    /**
     * Gets the file.
     *
     * @return the file
     * @throws IllegalStateException if constructed using a user provided {@link Tailable} implementation
     */
    public File getFile() {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (tailable instanceof TailablePath) {</span>
<span class="nc" id="L853">            return ((TailablePath) tailable).getPath().toFile();</span>
        }
<span class="nc" id="L855">        throw new IllegalStateException(&quot;Cannot extract java.io.File from &quot; + tailable.getClass().getName());</span>
    }

    /**
     * Gets whether to keep on running.
     *
     * @return whether to keep on running.
     * @since 2.5
     */
    protected boolean getRun() {
<span class="fc" id="L865">        return run;</span>
    }

    /**
     * Gets the Tailable.
     *
     * @return the Tailable
     * @since 2.12.0
     */
    public Tailable getTailable() {
<span class="fc" id="L875">        return tailable;</span>
    }

    /**
     * Reads new lines.
     *
     * @param reader The file to read
     * @return The new position after the lines have been read
     * @throws IOException if an I/O error occurs.
     */
    private long readLines(final RandomAccessResourceBridge reader) throws IOException {
<span class="fc" id="L886">        try (ByteArrayOutputStream lineBuf = new ByteArrayOutputStream(64)) {</span>
<span class="fc" id="L887">            long pos = reader.getPointer();</span>
<span class="fc" id="L888">            long rePos = pos; // position to re-read</span>
            int num;
<span class="fc" id="L890">            boolean seenCR = false;</span>
<span class="pc bpc" id="L891" title="1 of 4 branches missed.">            while (getRun() &amp;&amp; (num = reader.read(inbuf)) != EOF) {</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">                for (int i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L893">                    final byte ch = inbuf[i];</span>
<span class="fc bfc" id="L894" title="All 3 branches covered.">                    switch (ch) {</span>
                    case LF:
<span class="fc" id="L896">                        seenCR = false; // swallow CR before LF</span>
<span class="fc" id="L897">                        listener.handle(new String(lineBuf.toByteArray(), charset));</span>
<span class="fc" id="L898">                        lineBuf.reset();</span>
<span class="fc" id="L899">                        rePos = pos + i + 1;</span>
<span class="fc" id="L900">                        break;</span>
                    case CR:
<span class="fc bfc" id="L902" title="All 2 branches covered.">                        if (seenCR) {</span>
<span class="fc" id="L903">                            lineBuf.write(CR);</span>
                        }
<span class="fc" id="L905">                        seenCR = true;</span>
<span class="fc" id="L906">                        break;</span>
                    default:
<span class="fc bfc" id="L908" title="All 2 branches covered.">                        if (seenCR) {</span>
<span class="fc" id="L909">                            seenCR = false; // swallow final CR</span>
<span class="fc" id="L910">                            listener.handle(new String(lineBuf.toByteArray(), charset));</span>
<span class="fc" id="L911">                            lineBuf.reset();</span>
<span class="fc" id="L912">                            rePos = pos + i + 1;</span>
                        }
<span class="fc" id="L914">                        lineBuf.write(ch);</span>
                    }
                }
<span class="fc" id="L917">                pos = reader.getPointer();</span>
            }

<span class="fc" id="L920">            reader.seek(rePos); // Ensure we can re-read if necessary</span>

<span class="pc bpc" id="L922" title="1 of 2 branches missed.">            if (listener instanceof TailerListenerAdapter) {</span>
<span class="fc" id="L923">                ((TailerListenerAdapter) listener).endOfFileReached();</span>
            }

<span class="fc" id="L926">            return rePos;</span>
        }
    }

    /**
     * Follows changes in the file, calling {@link TailerListener#handle(String)} with each new line.
     */
    @Override
    public void run() {
<span class="fc" id="L935">        RandomAccessResourceBridge reader = null;</span>
        try {
<span class="fc" id="L937">            FileTime last = FileTimes.EPOCH; // The last time the file was checked for changes</span>
<span class="fc" id="L938">            long position = 0; // position within the file</span>
            // Open the file
<span class="fc bfc" id="L940" title="All 4 branches covered.">            while (getRun() &amp;&amp; reader == null) {</span>
                try {
<span class="fc" id="L942">                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);</span>
<span class="fc" id="L943">                } catch (final FileNotFoundException e) {</span>
<span class="fc" id="L944">                    listener.fileNotFound();</span>
<span class="fc" id="L945">                }</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">                if (reader == null) {</span>
<span class="fc" id="L947">                    ThreadUtils.sleep(delayDuration);</span>
                } else {
                    // The current position in the file
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">                    position = tailAtEnd ? tailable.size() : 0;</span>
<span class="fc" id="L951">                    last = tailable.lastModifiedFileTime();</span>
<span class="fc" id="L952">                    reader.seek(position);</span>
                }
            }
<span class="fc bfc" id="L955" title="All 2 branches covered.">            while (getRun()) {</span>
<span class="fc" id="L956">                final boolean newer = tailable.isNewer(last); // IO-279, must be done first</span>
                // Check the file length to see if it was rotated
<span class="fc" id="L958">                final long length = tailable.size();</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">                if (length &lt; position) {</span>
                    // File was rotated
<span class="fc" id="L961">                    listener.fileRotated();</span>
                    // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it
                    // successfully
<span class="fc" id="L964">                    try (RandomAccessResourceBridge save = reader) {</span>
<span class="fc" id="L965">                        reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);</span>
                        // At this point, we're sure that the old file is rotated
                        // Finish scanning the old file and then we'll start with the new one
                        try {
<span class="fc" id="L969">                            readLines(save);</span>
<span class="nc" id="L970">                        } catch (final IOException ioe) {</span>
<span class="nc" id="L971">                            listener.handle(ioe);</span>
<span class="fc" id="L972">                        }</span>
<span class="fc" id="L973">                        position = 0;</span>
<span class="nc" id="L974">                    } catch (final FileNotFoundException e) {</span>
                        // in this case we continue to use the previous reader and position values
<span class="nc" id="L976">                        listener.fileNotFound();</span>
<span class="nc" id="L977">                        ThreadUtils.sleep(delayDuration);</span>
<span class="fc" id="L978">                    }</span>
<span class="nc" id="L979">                    continue;</span>
                }
                // File was not rotated
                // See if the file needs to be read again
<span class="fc bfc" id="L983" title="All 2 branches covered.">                if (length &gt; position) {</span>
                    // The file has more content than it did last time
<span class="fc" id="L985">                    position = readLines(reader);</span>
<span class="fc" id="L986">                    last = tailable.lastModifiedFileTime();</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">                } else if (newer) {</span>
                    /*
                     * This can happen if the file is truncated or overwritten with the exact same length of information. In cases like
                     * this, the file position needs to be reset
                     */
<span class="fc" id="L992">                    position = 0;</span>
<span class="fc" id="L993">                    reader.seek(position); // cannot be null here</span>

                    // Now we can read new lines
<span class="fc" id="L996">                    position = readLines(reader);</span>
<span class="fc" id="L997">                    last = tailable.lastModifiedFileTime();</span>
                }
<span class="pc bpc" id="L999" title="1 of 4 branches missed.">                if (reOpen &amp;&amp; reader != null) {</span>
<span class="fc" id="L1000">                    reader.close();</span>
                }
<span class="fc" id="L1002">                ThreadUtils.sleep(delayDuration);</span>
<span class="fc bfc" id="L1003" title="All 4 branches covered.">                if (getRun() &amp;&amp; reOpen) {</span>
<span class="fc" id="L1004">                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);</span>
<span class="fc" id="L1005">                    reader.seek(position);</span>
                }
<span class="fc" id="L1007">            }</span>
<span class="fc" id="L1008">        } catch (final InterruptedException e) {</span>
<span class="fc" id="L1009">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L1010">            listener.handle(e);</span>
<span class="nc" id="L1011">        } catch (final Exception e) {</span>
<span class="nc" id="L1012">            listener.handle(e);</span>
        } finally {
            try {
<span class="fc" id="L1015">                IOUtils.close(reader);</span>
<span class="nc" id="L1016">            } catch (final IOException e) {</span>
<span class="nc" id="L1017">                listener.handle(e);</span>
<span class="fc" id="L1018">            }</span>
<span class="fc" id="L1019">            close();</span>
        }
<span class="fc" id="L1021">    }</span>

    /**
     * Requests the tailer to complete its current loop and return.
     *
     * @deprecated Use {@link #close()}.
     */
    @Deprecated
    public void stop() {
<span class="nc" id="L1030">        close();</span>
<span class="nc" id="L1031">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>