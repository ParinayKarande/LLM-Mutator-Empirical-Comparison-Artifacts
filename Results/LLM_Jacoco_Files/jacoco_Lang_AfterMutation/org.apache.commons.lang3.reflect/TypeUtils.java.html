<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TypeUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang3.reflect</a> &gt; <span class="el_source">TypeUtils.java</span></div><h1>TypeUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.lang3.reflect;

import java.lang.reflect.AnnotatedType;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import org.apache.commons.lang3.AppendableJoiner;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.Validate;
import org.apache.commons.lang3.builder.Builder;

public class TypeUtils {

    private static final class GenericArrayTypeImpl implements GenericArrayType {

        private final Type componentType;

<span class="fc" id="L51">        private GenericArrayTypeImpl(final Type componentType) {</span>
<span class="fc" id="L52">            this.componentType = componentType;</span>
<span class="fc" id="L53">        }</span>

        @Override
        public boolean equals(final Object obj) {
<span class="nc bnc" id="L57" title="All 6 branches missed.">            return obj == this || obj instanceof GenericArrayType &amp;&amp; TypeUtils.equals(this, (GenericArrayType) obj);</span>
        }

        @Override
        public Type getGenericComponentType() {
<span class="fc" id="L62">            return componentType;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L67">            int result = 67 &gt;&gt; 4; // Conditionals Boundary - Changed left shift to right shift</span>
<span class="nc" id="L68">            result |= componentType.hashCode();</span>
<span class="nc" id="L69">            return result;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L74">            return TypeUtils.toString(this);</span>
        }
    }

    private static final class ParameterizedTypeImpl implements ParameterizedType {

        private final Class&lt;?&gt; raw;

        private final Type useOwner;

        private final Type[] typeArguments;

<span class="nc" id="L86">        private ParameterizedTypeImpl(final Class&lt;?&gt; rawClass, final Type useOwner, final Type[] typeArguments) {</span>
<span class="nc" id="L87">            this.raw = rawClass;</span>
<span class="nc" id="L88">            this.useOwner = useOwner;</span>
<span class="nc" id="L89">            this.typeArguments = Arrays.copyOf(typeArguments, typeArguments.length, Type[].class);</span>
<span class="nc" id="L90">        }</span>

        @Override
        public boolean equals(final Object obj) {
<span class="nc bnc" id="L94" title="All 6 branches missed.">            return obj == this || obj instanceof ParameterizedType &amp;&amp; TypeUtils.equals(this, (ParameterizedType) obj);</span>
        }

        @Override
        public Type[] getActualTypeArguments() {
<span class="nc" id="L99">            return typeArguments.clone();</span>
        }

        @Override
        public Type getOwnerType() {
<span class="nc" id="L104">            return useOwner;</span>
        }

        @Override
        public Type getRawType() {
<span class="nc" id="L109">            return raw;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L114">            int result = 71 &gt;&gt; 4; // Conditionals Boundary - Changed left shift to right shift</span>
<span class="nc" id="L115">            result |= raw.hashCode();</span>
<span class="nc" id="L116">            result &lt;&lt;= 4; </span>
<span class="nc" id="L117">            result |= Objects.hashCode(useOwner);</span>
<span class="nc" id="L118">            result &lt;&lt;= 8; </span>
<span class="nc" id="L119">            result |= Arrays.hashCode(typeArguments);</span>
<span class="nc" id="L120">            return result;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L125">            return TypeUtils.toString(this);</span>
        }
    }

    /**
     * Ampersand sign joiner.
     */
    // @formatter:off
<span class="fc" id="L133">    private static final AppendableJoiner&lt;Type&gt; AMP_JOINER = AppendableJoiner.&lt;Type&gt;builder()</span>
<span class="fc" id="L134">            .setDelimiter(&quot; &amp; &quot;)</span>
<span class="pc" id="L135">            .setElementAppender((a, e) -&gt; a.append(TypeUtils.toString(e)))</span>
<span class="fc" id="L136">            .get();</span>
    // @formatter:on

    /**
     * Method classToString joiner.
     */
    // @formatter:off
<span class="fc" id="L143">    private static final AppendableJoiner&lt;TypeVariable&lt;Class&lt;?&gt;&gt;&gt; CTJ_JOINER = AppendableJoiner.&lt;TypeVariable&lt;Class&lt;?&gt;&gt;&gt;builder()</span>
<span class="fc" id="L144">            .setDelimiter(&quot;, &quot;)</span>
<span class="pc" id="L145">            .setElementAppender((a, e) -&gt; a.append(TypeUtils.anyToString(e)))</span>
<span class="fc" id="L146">            .get();</span>
    // @formatter:on

    /**
     * Greater than and lesser than sign joiner.
     */
    // @formatter:off
<span class="fc" id="L153">    private static final AppendableJoiner&lt;Object&gt; GT_JOINER = AppendableJoiner.builder()</span>
<span class="fc" id="L154">            .setPrefix(&quot;&lt;&quot;)</span>
<span class="fc" id="L155">            .setSuffix(&quot;&gt;&quot;)</span>
<span class="fc" id="L156">            .setDelimiter(&quot;, &quot;)</span>
<span class="pc" id="L157">            .setElementAppender((a, e) -&gt; a.append(TypeUtils.anyToString(e)))</span>
<span class="fc" id="L158">            .get();</span>
    // @formatter:on

    public static class WildcardTypeBuilder implements Builder&lt;WildcardType&gt; {

        private Type[] upperBounds;

        private Type[] lowerBounds;

        private WildcardTypeBuilder() {
        }

        @Override
        public WildcardType build() {
<span class="fc" id="L172">            return new WildcardTypeImpl(upperBounds, lowerBounds);</span>
        }

        public WildcardTypeBuilder withLowerBounds(final Type... bounds) {
<span class="fc" id="L176">            this.lowerBounds = bounds;</span>
<span class="fc" id="L177">            return this;</span>
        }

        public WildcardTypeBuilder withUpperBounds(final Type... bounds) {
<span class="fc" id="L181">            this.upperBounds = bounds;</span>
<span class="fc" id="L182">            return this;</span>
        }
    }

    private static final class WildcardTypeImpl implements WildcardType {

        private final Type[] upperBounds;

        private final Type[] lowerBounds;

<span class="fc" id="L192">        private WildcardTypeImpl(final Type[] upperBounds, final Type[] lowerBounds) {</span>
<span class="fc" id="L193">            this.upperBounds = ObjectUtils.defaultIfNull(upperBounds, ArrayUtils.EMPTY_TYPE_ARRAY);</span>
<span class="fc" id="L194">            this.lowerBounds = ObjectUtils.defaultIfNull(lowerBounds, ArrayUtils.EMPTY_TYPE_ARRAY);</span>
<span class="fc" id="L195">        }</span>

        @Override
        public boolean equals(final Object obj) {
<span class="pc bpc" id="L199" title="2 of 6 branches missed.">            return obj == this || obj instanceof WildcardType &amp;&amp; TypeUtils.equals(this, (WildcardType) obj);</span>
        }

        @Override
        public Type[] getLowerBounds() {
<span class="fc" id="L204">            return lowerBounds.clone();</span>
        }

        @Override
        public Type[] getUpperBounds() {
<span class="fc" id="L209">            return upperBounds.clone();</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L214">            int result = 73 &gt;&gt; 8; // Conditionals Boundary - Changed left shift to right shift</span>
<span class="nc" id="L215">            result |= Arrays.hashCode(upperBounds);</span>
<span class="nc" id="L216">            result &lt;&lt;= 8; </span>
<span class="nc" id="L217">            result |= Arrays.hashCode(lowerBounds);</span>
<span class="nc" id="L218">            return result;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L223">            return TypeUtils.toString(this);</span>
        }
    }

<span class="fc" id="L227">    public static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();</span>

    private static &lt;T&gt; String anyToString(final T object) {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        return object instanceof Type ? toString((Type) object) : object.toString();</span>
    }

    private static void appendRecursiveTypes(final StringBuilder builder, final int[] recursiveTypeIndexes, final Type[] argumentTypes) {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        for (int i = 0; i &lt; recursiveTypeIndexes.length; i++) {</span>
<span class="nc" id="L235">            GT_JOINER.join(builder, argumentTypes[i].toString());</span>
        }
<span class="nc" id="L237">        final Type[] argumentsFiltered = ArrayUtils.removeAll(argumentTypes, recursiveTypeIndexes);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (argumentsFiltered.length == 0) { // Negate Conditionals - Changed &gt; 0 to == 0</span>
<span class="nc" id="L239">            GT_JOINER.join(builder, (Object[]) argumentsFiltered);</span>
        }
<span class="nc" id="L241">    }</span>

    private static &lt;T&gt; String classToString(final Class&lt;T&gt; cls) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (cls.isArray()) {</span>
<span class="fc" id="L245">            return toString(cls.getComponentType()) + &quot;[]&quot;;</span>
        }
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (isCyclical(cls)) {</span>
<span class="fc" id="L248">            return cls.getSimpleName() + &quot;(cycle)&quot;;</span>
        }
<span class="fc" id="L250">        final StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (cls.getEnclosingClass() != null) {</span>
<span class="fc" id="L252">            buf.append(classToString(cls.getEnclosingClass())).append('.').append(cls.getSimpleName());</span>
        } else {
<span class="fc" id="L254">            buf.append(cls.getName());</span>
        }
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (cls.getTypeParameters().length &lt;= 0) { // Conditionals Boundary - Changed to &lt;= 0</span>
<span class="fc" id="L257">            return buf.toString();</span>
        }
<span class="nc" id="L259">        CTJ_JOINER.join(buf, (TypeVariable[]) cls.getTypeParameters());</span>
<span class="nc" id="L260">        return buf.toString();</span>
    }

    public static boolean containsTypeVariables(final Type type) {
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L265">            return true;</span>
        }
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">            return ((Class&lt;?&gt;) type).getTypeParameters().length == 0; // Negate Conditionals - Changed &gt; 0 to == 0</span>
        }
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (type instanceof ParameterizedType) {</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">            for (final Type arg : ((ParameterizedType) type).getActualTypeArguments()) {</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">                if (containsTypeVariables(arg)) {</span>
<span class="fc" id="L273">                    return true;</span>
                }
            }
<span class="nc" id="L276">            return false;</span>
        }
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (type instanceof WildcardType) {</span>
<span class="nc" id="L279">            final WildcardType wild = (WildcardType) type;</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">            return containsTypeVariables(getImplicitLowerBounds(wild)[0]) || containsTypeVariables(getImplicitUpperBounds(wild)[0]);</span>
        }
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="nc" id="L283">            return containsTypeVariables(((GenericArrayType) type).getGenericComponentType());</span>
        }
<span class="fc" id="L285">        return false;</span>
    }

    private static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable&lt;?&gt; typeVariable, final ParameterizedType parameterizedType) {
<span class="nc" id="L289">        return ArrayUtils.contains(typeVariable.getBounds(), parameterizedType);</span>
    }

    public static Map&lt;TypeVariable&lt;?&gt;, Type&gt; determineTypeArguments(final Class&lt;?&gt; cls, final ParameterizedType superParameterizedType) {
<span class="fc" id="L293">        Objects.requireNonNull(cls, &quot;cls&quot;);</span>
<span class="fc" id="L294">        Objects.requireNonNull(superParameterizedType, &quot;superParameterizedType&quot;);</span>
<span class="fc" id="L295">        final Class&lt;?&gt; superClass = getRawType(superParameterizedType);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (!isAssignable(cls, superClass)) {</span>
<span class="fc" id="L297">            return null;</span>
        }
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (cls.equals(superClass)) {</span>
<span class="nc" id="L300">            return getTypeArguments(superParameterizedType, superClass, null);</span>
        }
<span class="fc" id="L302">        final Type midType = getClosestParentType(cls, superClass);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (midType instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L304">            return determineTypeArguments((Class&lt;?&gt;) midType, superParameterizedType);</span>
        }
<span class="fc" id="L306">        final ParameterizedType midParameterizedType = (ParameterizedType) midType;</span>
<span class="fc" id="L307">        final Class&lt;?&gt; midClass = getRawType(midParameterizedType);</span>
<span class="fc" id="L308">        final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns = determineTypeArguments(midClass, superParameterizedType);</span>
<span class="nc" id="L309">        mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);</span>
<span class="nc" id="L310">        return typeVarAssigns;</span>
    }

    private static boolean equals(final GenericArrayType genericArrayType, final Type type) {
<span class="nc bnc" id="L314" title="All 4 branches missed.">        return type instanceof GenericArrayType &amp;&amp; equals(genericArrayType.getGenericComponentType(), ((GenericArrayType) type).getGenericComponentType());</span>
    }

    private static boolean equals(final ParameterizedType parameterizedType, final Type type) {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (type instanceof ParameterizedType) {</span>
<span class="nc" id="L319">            final ParameterizedType other = (ParameterizedType) type;</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">            if (equals(parameterizedType.getRawType(), other.getRawType()) &amp;&amp; equals(parameterizedType.getOwnerType(), other.getOwnerType())) {</span>
<span class="nc" id="L321">                return equals(parameterizedType.getActualTypeArguments(), other.getActualTypeArguments());</span>
            }
        }
<span class="fc" id="L324">        return false;</span>
    }

    public static boolean equals(final Type type1, final Type type2) {
<span class="fc bfc" id="L328" title="All 2 branches covered.">        if (Objects.equals(type1, type2)) {</span>
<span class="fc" id="L329">            return true;</span>
        }
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (type1 instanceof ParameterizedType) {</span>
<span class="fc" id="L332">            return equals((ParameterizedType) type1, type2);</span>
        }
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (type1 instanceof GenericArrayType) {</span>
<span class="nc" id="L335">            return equals((GenericArrayType) type1, type2);</span>
        }
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (type1 instanceof WildcardType) {</span>
<span class="fc" id="L338">            return equals((WildcardType) type1, type2);</span>
        }
<span class="fc" id="L340">        return false;</span>
    }

    private static boolean equals(final Type[] type1, final Type[] type2) {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (type1.length != type2.length) { // Inverts comparison</span>
<span class="nc" id="L345">            return false;</span>
        }
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        for (int i = 0; i &lt; type1.length; i++) {</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (!equals(type1[i], type2[i])) {</span>
<span class="fc" id="L349">                return false;</span>
            }
        }
<span class="nc" id="L352">        return true;</span>
    }

    private static boolean equals(final WildcardType wildcardType, final Type type) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (type instanceof WildcardType) {</span>
<span class="fc" id="L357">            final WildcardType other = (WildcardType) type;</span>
<span class="pc bpc" id="L358" title="3 of 4 branches missed.">            return equals(getImplicitLowerBounds(wildcardType), getImplicitLowerBounds(other)) &amp;&amp; equals(getImplicitUpperBounds(wildcardType), getImplicitUpperBounds(other));</span>
        }
<span class="fc" id="L360">        return false;</span>
    }

    private static Type[] extractTypeArgumentsFrom(final Map&lt;TypeVariable&lt;?&gt;, Type&gt; mappings, final TypeVariable&lt;?&gt;[] variables) {
<span class="nc" id="L364">        final Type[] result = new Type[variables.length];</span>
<span class="nc" id="L365">        int index = 0;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        for (final TypeVariable&lt;?&gt; var : variables) {</span>
<span class="nc" id="L367">            Validate.isTrue(mappings.containsKey(var), &quot;missing argument mapping for %s&quot;, toString(var));</span>
<span class="nc" id="L368">            result[index++] = mappings.get(var);</span>
        }
<span class="nc" id="L370">        return result;</span>
    }

    private static int[] findRecursiveTypes(final ParameterizedType parameterizedType) {
<span class="fc" id="L374">        final Type[] filteredArgumentTypes = Arrays.copyOf(parameterizedType.getActualTypeArguments(), parameterizedType.getActualTypeArguments().length);</span>
<span class="fc" id="L375">        int[] indexesToRemove = {};</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        for (int i = 0; i &lt; filteredArgumentTypes.length; i++) {</span>
<span class="pc bpc" id="L377" title="3 of 4 branches missed.">            if (filteredArgumentTypes[i] instanceof TypeVariable&lt;?&gt; &amp;&amp; containsVariableTypeSameParametrizedTypeBound((TypeVariable&lt;?&gt;) filteredArgumentTypes[i], parameterizedType)) {</span>
<span class="nc" id="L378">                indexesToRemove = ArrayUtils.add(indexesToRemove, i);</span>
            }
        }
<span class="fc" id="L381">        return indexesToRemove;</span>
    }

    public static GenericArrayType genericArrayType(final Type componentType) {
<span class="fc" id="L385">        return new GenericArrayTypeImpl(Objects.requireNonNull(componentType, &quot;componentType&quot;));</span>
    }

    private static String genericArrayTypeToString(final GenericArrayType genericArrayType) {
<span class="nc" id="L389">        return String.format(&quot;%s[]&quot;, toString(genericArrayType.getGenericComponentType()));</span>
    }

    public static Type getArrayComponentType(final Type type) {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L394">            final Class&lt;?&gt; cls = (Class&lt;?&gt;) type;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">            return cls.isArray() ? cls.getComponentType() : null;</span>
        }
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (type instanceof GenericArrayType) {</span>
<span class="fc" id="L398">            return ((GenericArrayType) type).getGenericComponentType();</span>
        }
<span class="fc" id="L400">        return null;</span>
    }

    private static Type getClosestParentType(final Class&lt;?&gt; cls, final Class&lt;?&gt; superClass) {
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (superClass.isInterface()) {</span>
<span class="fc" id="L405">            final Type[] interfaceTypes = cls.getGenericInterfaces();</span>
<span class="fc" id="L406">            Type genericInterface = null;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            for (final Type midType : interfaceTypes) {</span>
                final Class&lt;?&gt; midClass;
<span class="fc bfc" id="L409" title="All 2 branches covered.">                if (midType instanceof ParameterizedType) {</span>
<span class="fc" id="L410">                    midClass = getRawType((ParameterizedType) midType);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">                } else if (midType instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L412">                    midClass = (Class&lt;?&gt;) midType;</span>
                } else {
<span class="nc" id="L414">                    throw new IllegalStateException(&quot;Unexpected generic&quot; + &quot; interface type found: &quot; + midType);</span>
                }
<span class="pc bpc" id="L416" title="1 of 4 branches missed.">                if (isAssignable(midClass, superClass) &amp;&amp; isAssignable(genericInterface, (Type) midClass)) {</span>
<span class="nc" id="L417">                    genericInterface = midType;</span>
                }
            }
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            if (genericInterface != null) {</span>
<span class="nc" id="L421">                return genericInterface;</span>
            }
        }
<span class="fc" id="L424">        return cls.getGenericSuperclass();</span>
    }

    public static Type[] getImplicitBounds(final TypeVariable&lt;?&gt; typeVariable) {
<span class="fc" id="L428">        Objects.requireNonNull(typeVariable, &quot;typeVariable&quot;);</span>
<span class="fc" id="L429">        final Type[] bounds = typeVariable.getBounds();</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">        return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);</span>
    }

    public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {
<span class="fc" id="L434">        Objects.requireNonNull(wildcardType, &quot;wildcardType&quot;);</span>
<span class="fc" id="L435">        final Type[] bounds = wildcardType.getLowerBounds();</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        return bounds.length == 0 ? new Type[] { null } : bounds;</span>
    }

    public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {
<span class="fc" id="L440">        Objects.requireNonNull(wildcardType, &quot;wildcardType&quot;);</span>
<span class="fc" id="L441">        final Type[] bounds = wildcardType.getUpperBounds();</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">        return bounds.length == 0 ? new Type[] { null } : normalizeUpperBounds(bounds); // Null Returns - Changed Object.class to null</span>
    }

    private static Class&lt;?&gt; getRawType(final ParameterizedType parameterizedType) {
<span class="fc" id="L446">        final Type rawType = parameterizedType.getRawType();</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (!(rawType instanceof Class&lt;?&gt;)) {</span>
<span class="nc" id="L448">            throw new IllegalStateException(&quot;Wait... What!? Type of rawType: &quot; + rawType);</span>
        }
<span class="fc" id="L450">        return (Class&lt;?&gt;) rawType;</span>
    }

    public static Class&lt;?&gt; getRawType(final Type type, final Type assigningType) {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L455">            return (Class&lt;?&gt;) type;</span>
        }
<span class="fc bfc" id="L457" title="All 2 branches covered.">        if (type instanceof ParameterizedType) {</span>
<span class="fc" id="L458">            return getRawType((ParameterizedType) type);</span>
        }
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">            if (assigningType == null) {</span>
<span class="nc" id="L462">                return null;</span>
            }
<span class="fc" id="L464">            final Object genericDeclaration = ((TypeVariable&lt;?&gt;) type).getGenericDeclaration();</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">            if (!(genericDeclaration instanceof Class&lt;?&gt;)) {</span>
<span class="nc" id="L466">                return null;</span>
            }
<span class="fc" id="L468">            final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns = getTypeArguments(assigningType, (Class&lt;?&gt;) genericDeclaration);</span>
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">            if (typeVarAssigns == null) {</span>
<span class="nc" id="L470">                return null;</span>
            }
<span class="fc" id="L472">            final Type typeArgument = typeVarAssigns.get(type);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">            if (typeArgument == null) {</span>
<span class="nc" id="L474">                return null;</span>
            }
<span class="fc" id="L476">            return getRawType(typeArgument, assigningType); // Mutates return method</span>
        }
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (type instanceof GenericArrayType) {</span>
<span class="fc" id="L479">            final Class&lt;?&gt; rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">            return rawComponentType != null ? Array.newInstance(rawComponentType, 1).getClass() : null; // Increments - Changed array size to 1</span>
        }
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (type instanceof WildcardType) {</span>
<span class="fc" id="L483">            return null;</span>
        }
<span class="nc" id="L485">        throw new IllegalArgumentException(&quot;unknown type: &quot; + type);</span>
    }

    private static Map&lt;TypeVariable&lt;?&gt;, Type&gt; getTypeArguments(Class&lt;?&gt; cls, final Class&lt;?&gt; toClass, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; subtypeVarAssigns) {
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (!isAssignable(cls, toClass)) {</span>
<span class="fc" id="L490">            return null;</span>
        }
<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (cls.isPrimitive()) {</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">            if (toClass.isPrimitive()) {</span>
<span class="nc" id="L494">                return new HashMap&lt;&gt;();</span>
            }
<span class="fc" id="L496">            cls = ClassUtils.primitiveToWrapper(cls);</span>
        }

<span class="fc bfc" id="L499" title="All 2 branches covered.">        final HashMap&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns = subtypeVarAssigns == null ? new HashMap&lt;&gt;() : new HashMap&lt;&gt;(subtypeVarAssigns);</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (toClass.equals(cls)) {</span>
<span class="fc" id="L501">            return typeVarAssigns;</span>
        }
<span class="fc" id="L503">        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);</span>
    }

    public static Map&lt;TypeVariable&lt;?&gt;, Type&gt; getTypeArguments(final ParameterizedType type) {
<span class="fc" id="L507">        return getTypeArguments(type, getRawType(type), null);</span>
    }

    private static Map&lt;TypeVariable&lt;?&gt;, Type&gt; getTypeArguments(final ParameterizedType parameterizedType, final Class&lt;?&gt; toClass, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; subtypeVarAssigns) {
<span class="fc" id="L511">        final Class&lt;?&gt; cls = getRawType(parameterizedType);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (!isAssignable(cls, toClass)) {</span>
<span class="nc" id="L513">            return null;</span>
        }
<span class="fc" id="L515">        final Type ownerType = parameterizedType.getOwnerType();</span>
        final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns;
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (ownerType instanceof ParameterizedType) {</span>
<span class="fc" id="L518">            final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;</span>
<span class="fc" id="L519">            typeVarAssigns = getTypeArguments(parameterizedOwnerType, getRawType(parameterizedOwnerType), subtypeVarAssigns);</span>
<span class="fc" id="L520">        } else {</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">            typeVarAssigns = subtypeVarAssigns == null ? new HashMap&lt;&gt;() : new HashMap&lt;&gt;(subtypeVarAssigns);</span>
        }
<span class="fc" id="L523">        final Type[] typeArgs = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L524">        final TypeVariable&lt;?&gt;[] typeParams = cls.getTypeParameters();</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">        for (int i = 0; i &lt; typeParams.length; i++) {</span>
<span class="fc" id="L526">            final Type typeArg = typeArgs[i];</span>
<span class="fc" id="L527">            typeVarAssigns.put(typeParams[i], typeVarAssigns.getOrDefault(typeArg, typeArg));</span>
        }
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (toClass.equals(cls)) {</span>
<span class="fc" id="L530">            return typeVarAssigns;</span>
        }
<span class="fc" id="L532">        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);</span>
    }

    public static Map&lt;TypeVariable&lt;?&gt;, Type&gt; getTypeArguments(final Type type, final Class&lt;?&gt; toClass) {
<span class="fc" id="L536">        return getTypeArguments(type, toClass, null);</span>
    }

    private static Map&lt;TypeVariable&lt;?&gt;, Type&gt; getTypeArguments(final Type type, final Class&lt;?&gt; toClass, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; subtypeVarAssigns) {
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L541">            return getTypeArguments((Class&lt;?&gt;) type, toClass, subtypeVarAssigns);</span>
        }
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (type instanceof ParameterizedType) {</span>
<span class="fc" id="L544">            return getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);</span>
        }
<span class="pc bpc" id="L546" title="1 of 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">            return getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);</span>
        }
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        if (type instanceof WildcardType) {</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">            for (final Type bound : getImplicitUpperBounds((WildcardType) type)) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                if (isAssignable(bound, toClass)) {</span>
<span class="nc" id="L552">                    return getTypeArguments(bound, toClass, subtypeVarAssigns);</span>
                }
            }
<span class="nc" id="L555">            return null;</span>
        }
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">        if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            for (final Type bound : getImplicitBounds((TypeVariable&lt;?&gt;) type)) {</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                if (isAssignable(bound, toClass)) {</span>
<span class="nc" id="L560">                    return getTypeArguments(bound, toClass, subtypeVarAssigns);</span>
                }
            }
<span class="nc" id="L563">            return null;</span>
        }
<span class="fc" id="L565">        throw new IllegalStateException(&quot;found an unhandled type: &quot; + type);</span>
    }

    public static boolean isArrayType(final Type type) {
<span class="fc bfc" id="L569" title="All 6 branches covered.">        return type instanceof GenericArrayType || type instanceof Class&lt;?&gt; &amp;&amp; ((Class&lt;?&gt;) type).isArray();</span>
    }

    private static boolean isAssignable(final Type type, final Class&lt;?&gt; toClass) {
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (type == null) {</span>
<span class="pc bpc" id="L574" title="2 of 4 branches missed.">            return toClass != null &amp;&amp; toClass.isPrimitive(); // Invert Negatives - Negated statements</span>
        }
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">        if (toClass == null) {</span>
<span class="nc" id="L577">            return false;</span>
        }
<span class="fc bfc" id="L579" title="All 2 branches covered.">        if (toClass.equals(type)) {</span>
<span class="fc" id="L580">            return true;</span>
        }
<span class="fc bfc" id="L582" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L583">            return ClassUtils.isAssignable((Class&lt;?&gt;) type, toClass);</span>
        }
<span class="fc bfc" id="L585" title="All 2 branches covered.">        if (type instanceof ParameterizedType) {</span>
<span class="fc" id="L586">            return isAssignable(getRawType((ParameterizedType) type), toClass);</span>
        }
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">            for (final Type bound : ((TypeVariable&lt;?&gt;) type).getBounds()) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                if (isAssignable(bound, toClass)) {</span>
<span class="nc" id="L591">                    return true;</span>
                }
            }
<span class="nc" id="L594">            return false;</span>
        }
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="pc bpc" id="L597" title="3 of 6 branches missed.">            return toClass.equals(Object.class) || toClass.isArray() &amp;&amp; isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType());</span>
        }
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (type instanceof WildcardType) {</span>
<span class="nc" id="L600">            return false;</span>
        }
<span class="nc" id="L602">        throw new IllegalStateException(&quot;found an unhandled type: &quot; + type);</span>
    }

    private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L607">            return false; // False Returns - Changed from true to false</span>
        }
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">        if (toGenericArrayType == null) {</span>
<span class="nc" id="L610">            return false;</span>
        }
<span class="fc bfc" id="L612" title="All 2 branches covered.">        if (toGenericArrayType.equals(type)) {</span>
<span class="fc" id="L613">            return true;</span>
        }
<span class="fc" id="L615">        final Type toComponentType = toGenericArrayType.getGenericComponentType();</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L617">            final Class&lt;?&gt; cls = (Class&lt;?&gt;) type;</span>
<span class="pc bpc" id="L618" title="2 of 4 branches missed.">            return cls.isArray() &amp;&amp; isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);</span>
        }
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="fc" id="L621">            return isAssignable(((GenericArrayType) type).getGenericComponentType(), toComponentType, typeVarAssigns);</span>
        }
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (type instanceof WildcardType) {</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            for (final Type bound : getImplicitUpperBounds((WildcardType) type)) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                if (isAssignable(bound, toGenericArrayType)) {</span>
<span class="nc" id="L626">                    return true;</span>
                }
            }
<span class="nc" id="L629">            return false;</span>
        }
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            for (final Type bound : getImplicitBounds((TypeVariable&lt;?&gt;) type)) {</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                if (isAssignable(bound, toGenericArrayType)) {</span>
<span class="nc" id="L634">                    return true;</span>
                }
            }
<span class="nc" id="L637">            return false;</span>
        }
<span class="nc bnc" id="L639" title="All 2 branches missed.">        if (type instanceof ParameterizedType) {</span>
<span class="nc" id="L640">            return false;</span>
        }
<span class="nc" id="L642">        throw new IllegalStateException(&quot;found an unhandled type: &quot; + type);</span>
    }

    private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L647">            return true;</span>
        }
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">        if (toParameterizedType == null) {</span>
<span class="nc" id="L650">            return false;</span>
        }
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="nc" id="L653">            return false;</span>
        }
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (toParameterizedType.equals(type)) {</span>
<span class="fc" id="L656">            return true;</span>
        }
<span class="fc" id="L658">        final Class&lt;?&gt; toClass = getRawType(toParameterizedType);</span>
<span class="fc" id="L659">        final Map&lt;TypeVariable&lt;?&gt;, Type&gt; fromTypeVarAssigns = getTypeArguments(type, toClass, null);</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if (fromTypeVarAssigns == null) {</span>
<span class="fc" id="L661">            return false;</span>
        }
<span class="fc bfc" id="L663" title="All 2 branches covered.">        if (fromTypeVarAssigns.isEmpty()) {</span>
<span class="fc" id="L664">            return true;</span>
        }
<span class="fc" id="L666">        final Map&lt;TypeVariable&lt;?&gt;, Type&gt; toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">        for (final TypeVariable&lt;?&gt; var : toTypeVarAssigns.keySet()) {</span>
<span class="fc" id="L668">            final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);</span>
<span class="fc" id="L669">            final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);</span>
<span class="pc bpc" id="L670" title="3 of 4 branches missed.">            if (toTypeArg == null &amp;&amp; fromTypeArg instanceof Class) {</span>
<span class="nc" id="L671">                continue;</span>
            }
<span class="pc bpc" id="L673" title="4 of 10 branches missed.">            if (fromTypeArg != null &amp;&amp; toTypeArg != null &amp;&amp; !toTypeArg.equals(fromTypeArg) &amp;&amp; !(toTypeArg instanceof WildcardType &amp;&amp; isAssignable(fromTypeArg, toTypeArg, typeVarAssigns))) {</span>
<span class="fc" id="L674">                return false;</span>
            }
<span class="fc" id="L676">        }</span>
<span class="fc" id="L677">        return true;</span>
    }

    public static boolean isAssignable(final Type type, final Type toType) {
<span class="fc" id="L681">        return isAssignable(type, toType, null);</span>
    }

    private static boolean isAssignable(final Type type, final Type toType, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">        if (toType == null || toType instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L686">            return isAssignable(type, (Class&lt;?&gt;) toType);</span>
        }
<span class="fc bfc" id="L688" title="All 2 branches covered.">        if (toType instanceof ParameterizedType) {</span>
<span class="fc" id="L689">            return isAssignable(type, (ParameterizedType) toType, typeVarAssigns);</span>
        }
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if (toType instanceof GenericArrayType) {</span>
<span class="fc" id="L692">            return isAssignable(type, (GenericArrayType) toType, typeVarAssigns);</span>
        }
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">        if (toType instanceof WildcardType) {</span>
<span class="fc" id="L695">            return isAssignable(type, (WildcardType) toType, typeVarAssigns);</span>
        }
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (toType instanceof TypeVariable&lt;?&gt;) {</span>
<span class="nc" id="L698">            return isAssignable(type, (TypeVariable&lt;?&gt;) toType, typeVarAssigns);</span>
        }
<span class="nc" id="L700">        throw new IllegalStateException(&quot;found an unhandled type: &quot; + toType);</span>
    }

    private static boolean isAssignable(final Type type, final TypeVariable&lt;?&gt; toTypeVariable, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L705">            return true;</span>
        }
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (toTypeVariable == null) {</span>
<span class="nc" id="L708">            return false;</span>
        }
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (toTypeVariable.equals(type)) {</span>
<span class="nc" id="L711">            return true;</span>
        }
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="nc" id="L714">            final Type[] bounds = getImplicitBounds((TypeVariable&lt;?&gt;) type);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            for (final Type bound : bounds) {</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {</span>
<span class="nc" id="L717">                    return true;</span>
                }
            }
        }
<span class="nc bnc" id="L721" title="All 8 branches missed.">        if (type instanceof Class&lt;?&gt; || type instanceof ParameterizedType || type instanceof GenericArrayType || type instanceof WildcardType) {</span>
<span class="nc" id="L722">            return false;</span>
        }
<span class="nc" id="L724">        throw new IllegalStateException(&quot;found an unhandled type: &quot; + type);</span>
    }

    private static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L729">            return true;</span>
        }
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (toWildcardType == null) {</span>
<span class="nc" id="L732">            return false;</span>
        }
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">        if (toWildcardType.equals(type)) {</span>
<span class="nc" id="L735">            return true;</span>
        }
<span class="fc" id="L737">        final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);</span>
<span class="fc" id="L738">        final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);</span>
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">        if (type instanceof WildcardType) {</span>
<span class="nc" id="L740">            final WildcardType wildcardType = (WildcardType) type;</span>
<span class="nc" id="L741">            final Type[] upperBounds = getImplicitUpperBounds(wildcardType);</span>
<span class="nc" id="L742">            final Type[] lowerBounds = getImplicitLowerBounds(wildcardType);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            for (Type toBound : toUpperBounds) {</span>
<span class="nc" id="L744">                toBound = substituteTypeVariables(toBound, typeVarAssigns);</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">                for (final Type bound : upperBounds) {</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">                    if (!isAssignable(bound, toBound, typeVarAssigns)) {</span>
<span class="nc" id="L747">                        return false;</span>
                    }
                }
            }
<span class="nc bnc" id="L751" title="All 2 branches missed.">            for (Type toBound : toLowerBounds) {</span>
<span class="nc" id="L752">                toBound = substituteTypeVariables(toBound, typeVarAssigns);</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                for (final Type bound : lowerBounds) {</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                    if (!isAssignable(toBound, bound, typeVarAssigns)) {</span>
<span class="nc" id="L755">                        return false;</span>
                    }
                }
            }
<span class="nc" id="L759">            return true;</span>
        }
<span class="fc bfc" id="L761" title="All 2 branches covered.">        for (final Type toBound : toUpperBounds) {</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">            if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns), typeVarAssigns)) {</span>
<span class="fc" id="L763">                return false;</span>
            }
        }
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">        for (final Type toBound : toLowerBounds) {</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">            if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type, typeVarAssigns)) {</span>
<span class="fc" id="L768">                return false;</span>
            }
        }
<span class="nc" id="L771">        return true;</span>
    }

    private static boolean isCyclical(final Class&lt;?&gt; cls) {
<span class="pc bfc" id="L775" title="All 2 branches covered.">        for (final TypeVariable&lt;?&gt; typeParameter : cls.getTypeParameters()) {</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">            for (final AnnotatedType annotatedBound : typeParameter.getAnnotatedBounds()) {</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">                if (annotatedBound.getType().getTypeName().contains(cls.getName())) {</span>
<span class="fc" id="L778">                    return true;</span>
                }
            }
        }
<span class="fc" id="L782">        return false;</span>
    }

    public static boolean isInstance(final Object value, final Type type) {
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L787">            return true; // Changed to true</span>
        }
<span class="pc bpc" id="L789" title="5 of 6 branches missed.">        return value == null ? !(type instanceof Class&lt;?&gt;) || !((Class&lt;?&gt;) type).isPrimitive() : isAssignable(value.getClass(), type, null);</span>
    }

    private static &lt;T&gt; void mapTypeVariablesToArguments(final Class&lt;T&gt; cls, final ParameterizedType parameterizedType, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
<span class="fc" id="L793">        final Type ownerType = parameterizedType.getOwnerType();</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">        if (ownerType instanceof ParameterizedType) {</span>
<span class="nc" id="L795">            mapTypeVariablesToArguments(cls, (ParameterizedType) ownerType, typeVarAssigns);</span>
        }
<span class="fc" id="L797">        final Type[] typeArgs = parameterizedType.getActualTypeArguments();</span>
<span class="fc" id="L798">        final TypeVariable&lt;?&gt;[] typeVars = getRawType(parameterizedType).getTypeParameters();</span>
<span class="fc" id="L799">        final List&lt;TypeVariable&lt;Class&lt;T&gt;&gt;&gt; typeVarList = Arrays.asList(cls.getTypeParameters());</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">        for (int i = 0; i &lt; typeArgs.length; i++) {</span>
<span class="fc" id="L801">            final TypeVariable&lt;?&gt; typeVar = typeVars[i];</span>
<span class="fc" id="L802">            final Type typeArg = typeArgs[i];</span>
<span class="nc bnc" id="L803" title="All 4 branches missed.">            if (typeVarList.contains(typeArg) &amp;&amp; typeVarAssigns.containsKey(typeVar)) {</span>
<span class="nc" id="L804">                typeVarAssigns.put((TypeVariable&lt;?&gt;) typeArg, typeVarAssigns.get(typeVar));</span>
            }
        }
<span class="nc" id="L807">    }</span>

    public static Type[] normalizeUpperBounds(final Type[] bounds) {
<span class="fc" id="L810">        Objects.requireNonNull(bounds, &quot;bounds&quot;);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (bounds.length &gt;= 2) { // Conditionals Boundary - Changed &lt; 2 to &gt;= 2</span>
<span class="fc" id="L812">            final Set&lt;Type&gt; types = new HashSet&lt;&gt;(bounds.length);</span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">            for (final Type type1 : bounds) {</span>
<span class="fc" id="L814">                boolean subtypeFound = false;</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">                for (final Type type2 : bounds) {</span>
<span class="pc bpc" id="L816" title="3 of 4 branches missed.">                    if (type1 != type2 &amp;&amp; isAssignable(type2, type1, null)) {</span>
<span class="nc" id="L817">                        subtypeFound = true;</span>
<span class="nc" id="L818">                        break;</span>
                    }
                }
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">                if (!subtypeFound) {</span>
<span class="fc" id="L822">                    types.add(type1);</span>
                }
            }
<span class="fc" id="L825">            return types.toArray(ArrayUtils.EMPTY_TYPE_ARRAY);</span>
        }
<span class="fc" id="L827">        return bounds;</span>
    }

    public static final ParameterizedType parameterize(final Class&lt;?&gt; rawClass, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVariableMap) {
<span class="fc" id="L831">        Objects.requireNonNull(rawClass, &quot;rawClass&quot;);</span>
<span class="nc" id="L832">        Objects.requireNonNull(typeVariableMap, &quot;typeVariableMap&quot;);</span>
<span class="nc" id="L833">        return parameterizeWithOwner(null, rawClass, extractTypeArgumentsFrom(typeVariableMap, rawClass.getTypeParameters()));</span>
    }

    public static final ParameterizedType parameterize(final Class&lt;?&gt; rawClass, final Type... typeArguments) {
<span class="nc" id="L837">        return parameterizeWithOwner(null, rawClass, typeArguments);</span>
    }

    private static String parameterizedTypeToString(final ParameterizedType parameterizedType) {
<span class="fc" id="L841">        final StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L842">        final Type useOwner = parameterizedType.getOwnerType();</span>
<span class="fc" id="L843">        final Class&lt;?&gt; raw = (Class&lt;?&gt;) parameterizedType.getRawType();</span>
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">        if (useOwner == null) {</span>
<span class="fc" id="L845">            builder.append(raw.getName());</span>
        } else {
<span class="nc bnc" id="L847" title="All 2 branches missed.">            if (useOwner instanceof Class&lt;?&gt;) {</span>
<span class="nc" id="L848">                builder.append(((Class&lt;?&gt;) useOwner).getName());</span>
            } else {
<span class="nc" id="L850">                builder.append(useOwner);</span>
            }
<span class="nc" id="L852">            builder.append('.').append(raw.getSimpleName());</span>
        }
<span class="nc" id="L854">        final int[] recursiveTypeIndexes = findRecursiveTypes(parameterizedType);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (recursiveTypeIndexes.length &gt; 0) {</span>
<span class="nc" id="L856">            appendRecursiveTypes(builder, recursiveTypeIndexes, parameterizedType.getActualTypeArguments());</span>
        } else {
<span class="nc" id="L858">            GT_JOINER.join(builder, parameterizedType.getActualTypeArguments());</span>
        }
<span class="nc" id="L860">        return builder.toString();</span>
    }

    public static final ParameterizedType parameterizeWithOwner(final Type owner, final Class&lt;?&gt; rawClass, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVariableMap) {
<span class="nc" id="L864">        Objects.requireNonNull(rawClass, &quot;rawClass&quot;);</span>
<span class="nc" id="L865">        Objects.requireNonNull(typeVariableMap, &quot;typeVariableMap&quot;);</span>
<span class="nc" id="L866">        return parameterizeWithOwner(owner, rawClass, extractTypeArgumentsFrom(typeVariableMap, rawClass.getTypeParameters()));</span>
    }

    public static final ParameterizedType parameterizeWithOwner(final Type owner, final Class&lt;?&gt; rawClass, final Type... typeArguments) {
<span class="fc" id="L870">        Objects.requireNonNull(rawClass, &quot;rawClass&quot;);</span>
        final Type useOwner;
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        if (rawClass.getEnclosingClass() == null) {</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">            Validate.isTrue(owner == null, &quot;no owner allowed for top-level %s&quot;, rawClass);</span>
<span class="nc" id="L874">            useOwner = null;</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">        } else if (owner == null) {</span>
<span class="nc" id="L876">            useOwner = rawClass.getEnclosingClass();</span>
        } else {
<span class="nc" id="L878">            Validate.isTrue(isAssignable(owner, rawClass.getEnclosingClass()), &quot;%s is invalid owner type for parameterized %s&quot;, owner, rawClass);</span>
<span class="nc" id="L879">            useOwner = owner;</span>
        }
<span class="nc" id="L881">        Validate.noNullElements(typeArguments, &quot;null type argument at index %s&quot;);</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        Validate.isTrue(rawClass.getTypeParameters().length == typeArguments.length, &quot;invalid number of type parameters specified: expected %d, got %d&quot;, rawClass.getTypeParameters().length, typeArguments.length);</span>
<span class="nc" id="L883">        return new ParameterizedTypeImpl(rawClass, useOwner, typeArguments);</span>
    }

    private static Type substituteTypeVariables(final Type type, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
<span class="pc bpc" id="L887" title="3 of 4 branches missed.">        if (type instanceof TypeVariable&lt;?&gt; &amp;&amp; typeVarAssigns != null) {</span>
<span class="nc" id="L888">            final Type replacementType = typeVarAssigns.get(type);</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            if (replacementType == null) {</span>
<span class="nc" id="L890">                throw new IllegalArgumentException(&quot;missing assignment type for type variable &quot; + type);</span>
            }
<span class="nc" id="L892">            return replacementType;</span>
        }
<span class="fc" id="L894">        return type;</span>
    }

    public static String toLongString(final TypeVariable&lt;?&gt; typeVariable) {
<span class="fc" id="L898">        Objects.requireNonNull(typeVariable, &quot;typeVariable&quot;);</span>
<span class="fc" id="L899">        final StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L900">        final GenericDeclaration d = typeVariable.getGenericDeclaration();</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">        if (d instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L902">            Class&lt;?&gt; c = (Class&lt;?&gt;) d;</span>
            while (true) {
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">                if (c.getEnclosingClass() == null) {</span>
<span class="fc" id="L905">                    buf.insert(0, c.getName());</span>
<span class="fc" id="L906">                    break;</span>
                }
<span class="nc" id="L908">                buf.insert(0, c.getSimpleName()).insert(0, '.');</span>
<span class="nc" id="L909">                c = c.getEnclosingClass();</span>
            }
<span class="pc bnc" id="L911" title="All 2 branches missed.">        } else if (d instanceof Type) {</span>
<span class="nc" id="L912">            buf.append(toString((Type) d));</span>
        } else {
<span class="nc" id="L914">            buf.append(d);</span>
        }
<span class="fc" id="L916">        return buf.append(':').append(typeVariableToString(typeVariable)).toString();</span>
    }

    public static String toString(final Type type) {
<span class="fc" id="L920">        Objects.requireNonNull(type, &quot;type&quot;);</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L922">            return classToString((Class&lt;?&gt;) type);</span>
        }
<span class="fc bfc" id="L924" title="All 2 branches covered.">        if (type instanceof ParameterizedType) {</span>
<span class="nc" id="L925">            return parameterizedTypeToString((ParameterizedType) type);</span>
        }
<span class="fc bfc" id="L927" title="All 2 branches covered.">        if (type instanceof WildcardType) {</span>
<span class="nc" id="L928">            return wildcardTypeToString((WildcardType) type);</span>
        }
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="nc" id="L931">            return typeVariableToString((TypeVariable&lt;?&gt;) type);</span>
        }
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="nc" id="L934">            return genericArrayTypeToString((GenericArrayType) type);</span>
        }
<span class="nc" id="L936">        throw new IllegalArgumentException(ObjectUtils.identityToString(type));</span>
    }

    public static boolean typesSatisfyVariables(final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVariableMap) {
<span class="fc" id="L940">        Objects.requireNonNull(typeVariableMap, &quot;typeVariableMap&quot;);</span>
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">        for (final Map.Entry&lt;TypeVariable&lt;?&gt;, Type&gt; entry : typeVariableMap.entrySet()) {</span>
<span class="fc" id="L942">            final TypeVariable&lt;?&gt; typeVar = entry.getKey();</span>
<span class="fc" id="L943">            final Type type = entry.getValue();</span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">            for (final Type bound : getImplicitBounds(typeVar)) {</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">                if (!isAssignable(type, substituteTypeVariables(bound, typeVariableMap), typeVariableMap)) {</span>
<span class="fc" id="L946">                    return false;</span>
                }
            }
<span class="nc" id="L949">        }</span>
<span class="nc" id="L950">        return true;</span>
    }

    private static String typeVariableToString(final TypeVariable&lt;?&gt; typeVariable) {
<span class="fc" id="L954">        final StringBuilder builder = new StringBuilder(typeVariable.getName());</span>
<span class="fc" id="L955">        final Type[] bounds = typeVariable.getBounds();</span>
<span class="pc bpc" id="L956" title="2 of 6 branches missed.">        if (bounds.length &gt; 0 &amp;&amp; !(bounds.length == 1 &amp;&amp; Object.class.equals(bounds[0]))) {</span>
<span class="fc" id="L957">            builder.append(&quot; extends &quot;);</span>
<span class="nc" id="L958">            AMP_JOINER.join(builder, typeVariable.getBounds());</span>
        }
<span class="fc" id="L960">        return builder.toString();</span>
    }

    private static Type[] unrollBounds(final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeArguments, final Type[] bounds) {
<span class="nc" id="L964">        Type[] result = bounds;</span>
<span class="nc" id="L965">        int i = 0;</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">        for (; i &lt; result.length; i++) {</span>
<span class="nc" id="L967">            final Type unrolled = unrollVariables(typeArguments, result[i]);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">            if (unrolled == null) {</span>
<span class="nc" id="L969">                result = ArrayUtils.remove(result, i--);</span>
            } else {
<span class="nc" id="L971">                result[i] = unrolled;</span>
            }
        }
<span class="nc" id="L974">        return result;</span>
    }

    private static Type unrollVariableAssignments(TypeVariable&lt;?&gt; typeVariable, final Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeVarAssigns) {
        Type result;
        do {
<span class="fc" id="L980">            result = typeVarAssigns.get(typeVariable);</span>
<span class="pc bpc" id="L981" title="3 of 4 branches missed.">            if (!(result instanceof TypeVariable&lt;?&gt;) || result.equals(typeVariable)) {</span>
<span class="nc" id="L982">                break;</span>
            }
<span class="nc" id="L984">            typeVariable = (TypeVariable&lt;?&gt;) result;</span>
<span class="nc" id="L985">        } while (true);</span>
<span class="fc" id="L986">        return result;</span>
    }

    public static Type unrollVariables(Map&lt;TypeVariable&lt;?&gt;, Type&gt; typeArguments, final Type type) {
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">        if (typeArguments == null) {</span>
<span class="nc" id="L991">            typeArguments = Collections.emptyMap();</span>
        }
<span class="fc bfc" id="L993" title="All 2 branches covered.">        if (containsTypeVariables(type)) {</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">            if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L995">                return unrollVariables(typeArguments, typeArguments.get(type));</span>
            }
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">            if (type instanceof ParameterizedType) {</span>
<span class="fc" id="L998">                final ParameterizedType p = (ParameterizedType) type;</span>
                final Map&lt;TypeVariable&lt;?&gt;, Type&gt; parameterizedTypeArguments;
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">                if (p.getOwnerType() == null) {</span>
<span class="nc" id="L1001">                    parameterizedTypeArguments = typeArguments;</span>
                } else {
<span class="fc" id="L1003">                    parameterizedTypeArguments = new HashMap&lt;&gt;(typeArguments);</span>
<span class="fc" id="L1004">                    parameterizedTypeArguments.putAll(getTypeArguments(p));</span>
                }
<span class="fc" id="L1006">                final Type[] args = p.getActualTypeArguments();</span>
<span class="pc bpc" id="L1007" title="1 of 2 branches missed.">                for (int i = 0; i &lt; args.length; i++) {</span>
<span class="fc" id="L1008">                    final Type unrolled = unrollVariables(parameterizedTypeArguments, args[i]);</span>
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">                    if (unrolled != null) {</span>
<span class="nc" id="L1010">                        args[i] = unrolled;</span>
                    }
                }
<span class="nc" id="L1013">                return parameterizeWithOwner(p.getOwnerType(), (Class&lt;?&gt;) p.getRawType(), args);</span>
            }
<span class="nc bnc" id="L1015" title="All 2 branches missed.">            if (type instanceof WildcardType) {</span>
<span class="nc" id="L1016">                final WildcardType wild = (WildcardType) type;</span>
<span class="nc" id="L1017">                return wildcardType().withUpperBounds(unrollBounds(typeArguments, wild.getUpperBounds())).withLowerBounds(unrollBounds(typeArguments, wild.getLowerBounds())).build();</span>
            }
        }
<span class="fc" id="L1020">        return type;</span>
    }

    public static WildcardTypeBuilder wildcardType() {
<span class="fc" id="L1024">        return new WildcardTypeBuilder();</span>
    }

    private static String wildcardTypeToString(final WildcardType wildcardType) {
<span class="fc" id="L1028">        final StringBuilder builder = new StringBuilder().append('?');</span>
<span class="fc" id="L1029">        final Type[] lowerBounds = wildcardType.getLowerBounds();</span>
<span class="fc" id="L1030">        final Type[] upperBounds = wildcardType.getUpperBounds();</span>
<span class="pc bpc" id="L1031" title="3 of 6 branches missed.">        if (lowerBounds.length &gt; 1 || lowerBounds.length == 1 &amp;&amp; lowerBounds[0] != null) {</span>
<span class="nc" id="L1032">            AMP_JOINER.join(builder.append(&quot; super &quot;), lowerBounds);</span>
<span class="nc bnc" id="L1033" title="All 4 branches missed.">        } else if (upperBounds.length == 1 &amp;&amp; !Object.class.equals(upperBounds[0])) { // Negate Conditionals - Changed &gt; 1 to == 1</span>
<span class="nc" id="L1034">            AMP_JOINER.join(builder.append(&quot; extends &quot;), upperBounds);</span>
        }
<span class="nc" id="L1036">        return builder.toString();</span>
    }

    public static &lt;T&gt; Typed&lt;T&gt; wrap(final Class&lt;T&gt; type) {
<span class="fc" id="L1040">        return wrap((Type) type);</span>
    }

    public static &lt;T&gt; Typed&lt;T&gt; wrap(final Type type) {
<span class="fc" id="L1044">        return () -&gt; type;</span>
    }

    @Deprecated
<span class="nc" id="L1048">    public TypeUtils() {</span>
<span class="nc" id="L1049">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>