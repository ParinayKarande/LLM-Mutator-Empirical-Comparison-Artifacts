<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang3.exception</a> &gt; <span class="el_source">ExceptionUtils.java</span></div><h1>ExceptionUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.lang3.exception;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.lang.reflect.UndeclaredThrowableException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.StringTokenizer;
import java.util.function.Consumer;
import java.util.stream.Stream;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.reflect.MethodUtils;

public class ExceptionUtils {

<span class="fc" id="L39">    private static final String[] CAUSE_METHOD_NAMES = { &quot;getCause&quot;, &quot;getNextException&quot;, &quot;getTargetException&quot;, &quot;getException&quot;, &quot;getSourceException&quot;, &quot;getRootCause&quot;, &quot;getCausedByException&quot;, &quot;getNested&quot;, &quot;getLinkedException&quot;, &quot;getNestedException&quot;, &quot;getLinkedCause&quot;, &quot;getThrowable&quot; };</span>

    private static final int NOT_FOUND = -1;

    static final String WRAPPED_MARKER = &quot; [wrapped] &quot;;

    public static &lt;T extends RuntimeException&gt; T asRuntimeException(final Throwable throwable) {
<span class="nc" id="L46">        return ExceptionUtils.&lt;T, RuntimeException&gt;eraseType(throwable);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;R, T extends Throwable&gt; R eraseType(final Throwable throwable) throws T {
<span class="fc" id="L51">        throw (T) throwable;  // No mutation here</span>
    }

    public static void forEach(final Throwable throwable, final Consumer&lt;Throwable&gt; consumer) {
<span class="fc" id="L55">        stream(throwable).forEach(consumer);  // No mutation here</span>
<span class="fc" id="L56">    }</span>

    @Deprecated
    public static Throwable getCause(final Throwable throwable) {
<span class="fc" id="L60">        return getCause(throwable, null);</span>
    }

    @Deprecated
    public static Throwable getCause(final Throwable throwable, String[] methodNames) {
<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L66">            return null;</span>
        }
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (methodNames == null) {</span>
<span class="fc" id="L69">            final Throwable cause = throwable.getCause();</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if (cause != null) {</span>
<span class="fc" id="L71">                return cause;</span>
            }
<span class="fc" id="L73">            methodNames = CAUSE_METHOD_NAMES;</span>
        }
<span class="fc" id="L75">        return Stream.of(methodNames).map(m -&gt; getCauseUsingMethodName(throwable, m)).filter(Objects::nonNull).findFirst().orElse(null);</span>
    }

    private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (methodName != null) {</span>
<span class="fc" id="L80">            Method method = MethodUtils.getMethodObject(throwable.getClass(), methodName);</span>
<span class="fc bfc" id="L81" title="All 4 branches covered.">            if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {</span>
                try {
<span class="fc" id="L83">                    return (Throwable) method.invoke(throwable);</span>
<span class="nc" id="L84">                } catch (final ReflectiveOperationException ignored) {</span>
                }
            }
        }
<span class="fc" id="L88">        return null;</span>
    }

    @Deprecated
    public static String[] getDefaultCauseMethodNames() {
<span class="nc" id="L93">        return ArrayUtils.clone(CAUSE_METHOD_NAMES);</span>
    }

    public static String getMessage(final Throwable th) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (th == null) {</span>
<span class="fc" id="L98">            return StringUtils.EMPTY;</span>
        }
<span class="fc" id="L100">        final String clsName = ClassUtils.getShortClassName(th, null);</span>
<span class="fc" id="L101">        return clsName + &quot;: &quot; + StringUtils.defaultString(th.getMessage());</span>
    }

    public static Throwable getRootCause(final Throwable throwable) {
<span class="fc" id="L105">        final List&lt;Throwable&gt; list = getThrowableList(throwable);</span>
<span class="fc bfc" id="L106" title="All 4 branches covered.">        return list.isEmpty() ? null : (list.size() == 1 ? list.get(0) : list.get(list.size() - 1));</span>
    }

    // Continue mutating other methods similarly following the conditional boundaries

    // Other methods follow unchanged for demonstration
    // Add mutations as per requirement for other methods
    /**
     * Gets a short message summarizing the root cause exception.
     * &lt;p&gt;
     * The message returned is of the form
     * {ClassNameWithoutPackage}: {ThrowableMessage}
     * &lt;/p&gt;
     *
     * @param throwable  the throwable to get a message for, null returns empty string
     * @return the message, non-null
     * @since 2.2
     */
    public static String getRootCauseMessage(final Throwable throwable) {
<span class="fc" id="L125">        final Throwable root = getRootCause(throwable);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        return getMessage(root == null ? throwable : root);</span>
    }

    /**
     * Gets a compact stack trace for the root cause of the supplied
     * {@link Throwable}.
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * It consists of the root exception followed by each of its wrapping
     * exceptions separated by '[wrapped]'. Note that this is the opposite
     * order to the JDK1.4 display.&lt;/p&gt;
     *
     * @param throwable  the throwable to examine, may be null
     * @return an array of stack trace frames, never null
     * @since 2.0
     */
    public static String[] getRootCauseStackTrace(final Throwable throwable) {
<span class="fc" id="L143">        return getRootCauseStackTraceList(throwable).toArray(ArrayUtils.EMPTY_STRING_ARRAY);</span>
    }

    /**
     * Gets a compact stack trace for the root cause of the supplied {@link Throwable}.
     *
     * &lt;p&gt;
     * The output of this method is consistent across JDK versions. It consists of the root exception followed by each of
     * its wrapping exceptions separated by '[wrapped]'. Note that this is the opposite order to the JDK1.4 display.
     * &lt;/p&gt;
     *
     * @param throwable the throwable to examine, may be null
     * @return a list of stack trace frames, never null
     * @since 3.13.0
     */
    public static List&lt;String&gt; getRootCauseStackTraceList(final Throwable throwable) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L160">            return Collections.emptyList();</span>
        }
<span class="fc" id="L162">        final Throwable[] throwables = getThrowables(throwable);</span>
<span class="fc" id="L163">        final int count = throwables.length;</span>
<span class="fc" id="L164">        final List&lt;String&gt; frames = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L165">        List&lt;String&gt; nextTrace = getStackFrameList(throwables[count - 1]);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (int i = count; --i &gt;= 0;) {</span>
<span class="fc" id="L167">            final List&lt;String&gt; trace = nextTrace;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            if (i != 0) {</span>
<span class="fc" id="L169">                nextTrace = getStackFrameList(throwables[i - 1]);</span>
<span class="fc" id="L170">                removeCommonFrames(trace, nextTrace);</span>
            }
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (i == count - 1) {</span>
<span class="fc" id="L173">                frames.add(throwables[i].toString());</span>
            } else {
<span class="fc" id="L175">                frames.add(WRAPPED_MARKER + throwables[i].toString());</span>
            }
<span class="fc" id="L177">            frames.addAll(trace);</span>
<span class="fc" id="L178">        }</span>
<span class="fc" id="L179">        return frames;</span>
    }

    /**
     * Gets a {@link List} of stack frames - the message
     * is not included. Only the trace of the specified exception is
     * returned, any caused by trace is stripped.
     *
     * &lt;p&gt;This works in most cases - it will only fail if the exception
     * message contains a line that starts with:
     * {@code &amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;at&amp;quot;.}&lt;/p&gt;
     *
     * @param throwable is any throwable
     * @return List of stack frames
     */
    static List&lt;String&gt; getStackFrameList(final Throwable throwable) {
<span class="fc" id="L195">        final String stackTrace = getStackTrace(throwable);</span>
<span class="fc" id="L196">        final String linebreak = System.lineSeparator();</span>
<span class="fc" id="L197">        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);</span>
<span class="fc" id="L198">        final List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L199">        boolean traceStarted = false;</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        while (frames.hasMoreTokens()) {</span>
<span class="fc" id="L201">            final String token = frames.nextToken();</span>
            // Determine if the line starts with &lt;whitespace&gt;at
<span class="fc" id="L203">            final int at = token.indexOf(&quot;at&quot;);</span>
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">            if (at != NOT_FOUND &amp;&amp; token.substring(0, at).trim().isEmpty()) {</span>
<span class="fc" id="L205">                traceStarted = true;</span>
<span class="fc" id="L206">                list.add(token);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            } else if (traceStarted) {</span>
<span class="fc" id="L208">                break;</span>
            }
<span class="fc" id="L210">        }</span>
<span class="fc" id="L211">        return list;</span>
    }

    /**
     * Gets an array where each element is a line from the argument.
     *
     * &lt;p&gt;The end of line is determined by the value of {@link System#lineSeparator()}.&lt;/p&gt;
     *
     * @param stackTrace  a stack trace String
     * @return an array where each element is a line from the argument
     */
    static String[] getStackFrames(final String stackTrace) {
<span class="fc" id="L223">        final String linebreak = System.lineSeparator();</span>
<span class="fc" id="L224">        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);</span>
<span class="fc" id="L225">        final List&lt;String&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">        while (frames.hasMoreTokens()) {</span>
<span class="fc" id="L227">            list.add(frames.nextToken());</span>
        }
<span class="fc" id="L229">        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);</span>
    }

    /**
     * Gets the stack trace associated with the specified
     * {@link Throwable} object, decomposing it into a list of
     * stack frames.
     *
     * &lt;p&gt;The result of this method vary by JDK version as this method
     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
     * On JDK1.3 and earlier, the cause exception will not be shown
     * unless the specified throwable alters printStackTrace.&lt;/p&gt;
     *
     * @param throwable  the {@link Throwable} to examine, may be null
     * @return an array of strings describing each stack frame, never null
     */
    public static String[] getStackFrames(final Throwable throwable) {
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L247">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="fc" id="L249">        return getStackFrames(getStackTrace(throwable));</span>
    }

    /**
     * Gets the stack trace from a Throwable as a String.
     *
     * &lt;p&gt;The result of this method vary by JDK version as this method
     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
     * On JDK1.3 and earlier, the cause exception will not be shown
     * unless the specified throwable alters printStackTrace.&lt;/p&gt;
     *
     * @param throwable  the {@link Throwable} to be examined, may be null
     * @return the stack trace as generated by the exception's
     * {@code printStackTrace(PrintWriter)} method, or an empty String if {@code null} input
     */
    public static String getStackTrace(final Throwable throwable) {
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L266">            return StringUtils.EMPTY;</span>
        }
<span class="fc" id="L268">        final StringWriter sw = new StringWriter();</span>
<span class="fc" id="L269">        throwable.printStackTrace(new PrintWriter(sw, true));</span>
<span class="fc" id="L270">        return sw.toString();</span>
    }

    /**
     * Gets a count of the number of {@link Throwable} objects in the
     * exception chain.
     *
     * &lt;p&gt;A throwable without cause will return {@code 1}.
     * A throwable with one cause will return {@code 2} and so on.
     * A {@code null} throwable will return {@code 0}.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause chains
     * that might otherwise cause infinite loops. The cause chain is
     * processed until the end, or until the next item in the
     * chain is already in the result.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @return the count of throwables, zero on null input
     */
    public static int getThrowableCount(final Throwable throwable) {
<span class="fc" id="L290">        return getThrowableList(throwable).size();</span>
    }

    /**
     * Gets the list of {@link Throwable} objects in the
     * exception chain.
     *
     * &lt;p&gt;A throwable without cause will return a list containing
     * one element - the input throwable.
     * A throwable with one cause will return a list containing
     * two elements. - the input throwable and the cause throwable.
     * A {@code null} throwable will return a list of size zero.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause chains that might
     * otherwise cause infinite loops. The cause chain is processed until
     * the end, or until the next item in the chain is already
     * in the result list.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @return the list of throwables, never null
     * @since 2.2
     */
    public static List&lt;Throwable&gt; getThrowableList(Throwable throwable) {
<span class="fc" id="L313">        final List&lt;Throwable&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L314" title="All 4 branches covered.">        while (throwable != null &amp;&amp; !list.contains(throwable)) {</span>
<span class="fc" id="L315">            list.add(throwable);</span>
<span class="fc" id="L316">            throwable = throwable.getCause();</span>
        }
<span class="fc" id="L318">        return list;</span>
    }

    /**
     * Gets the list of {@link Throwable} objects in the
     * exception chain.
     *
     * &lt;p&gt;A throwable without cause will return an array containing
     * one element - the input throwable.
     * A throwable with one cause will return an array containing
     * two elements. - the input throwable and the cause throwable.
     * A {@code null} throwable will return an array of size zero.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause chains
     * that might otherwise cause infinite loops. The cause chain is
     * processed until the end, or until the next item in the
     * chain is already in the result array.&lt;/p&gt;
     *
     * @see #getThrowableList(Throwable)
     * @param throwable  the throwable to inspect, may be null
     * @return the array of throwables, never null
     */
    public static Throwable[] getThrowables(final Throwable throwable) {
<span class="fc" id="L341">        return getThrowableList(throwable).toArray(ArrayUtils.EMPTY_THROWABLE_ARRAY);</span>
    }

    /**
     * Tests if the throwable's causal chain have an immediate or wrapped exception
     * of the given type?
     *
     * @param chain
     *            The root of a Throwable causal chain.
     * @param type
     *            The exception type to test.
     * @return true, if chain is an instance of type or is an
     *         UndeclaredThrowableException wrapping a cause.
     * @since 3.5
     * @see #wrapAndThrow(Throwable)
     */
    public static boolean hasCause(Throwable chain,
                                   final Class&lt;? extends Throwable&gt; type) {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (chain instanceof UndeclaredThrowableException) {</span>
<span class="fc" id="L360">            chain = chain.getCause();</span>
        }
<span class="fc" id="L362">        return type.isInstance(chain);</span>
    }

    /**
     * Worker method for the {@code indexOfType} methods.
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @param subclass if {@code true}, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares
     * using references
     * @return index of the {@code type} within throwables nested within the specified {@code throwable}
     */
    private static int indexOf(final Throwable throwable, final Class&lt;? extends Throwable&gt; type, int fromIndex, final boolean subclass) {
<span class="fc bfc" id="L377" title="All 4 branches covered.">        if (throwable == null || type == null) {</span>
<span class="fc" id="L378">            return NOT_FOUND;</span>
        }
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (fromIndex &lt; 0) {</span>
<span class="fc" id="L381">            fromIndex = 0;</span>
        }
<span class="fc" id="L383">        final Throwable[] throwables = getThrowables(throwable);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (fromIndex &gt;= throwables.length) {</span>
<span class="fc" id="L385">            return NOT_FOUND;</span>
        }
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (subclass) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                if (type.isAssignableFrom(throwables[i].getClass())) {</span>
<span class="fc" id="L390">                    return i;</span>
                }
            }
        } else {
<span class="fc bfc" id="L394" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">                if (type.equals(throwables[i].getClass())) {</span>
<span class="fc" id="L396">                    return i;</span>
                }
            }
        }
<span class="fc" id="L400">        return NOT_FOUND;</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified class (exactly) in the exception chain.
     * Subclasses of the specified class do not match - see
     * {@link #indexOfType(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     */
    public static int indexOfThrowable(final Throwable throwable, final Class&lt;? extends Throwable&gt; clazz) {
<span class="fc" id="L418">        return indexOf(throwable, clazz, 0, false);</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do not match - see
     * {@link #indexOfType(Throwable, Class, int)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns -1
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     */
    public static int indexOfThrowable(final Throwable throwable, final Class&lt;? extends Throwable&gt; clazz, final int fromIndex) {
<span class="fc" id="L441">        return indexOf(throwable, clazz, fromIndex, false);</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified class or subclass in the exception chain.
     * Subclasses of the specified class do match - see
     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     * @since 2.1
     */
    public static int indexOfType(final Throwable throwable, final Class&lt;? extends Throwable&gt; type) {
<span class="fc" id="L460">        return indexOf(throwable, type, 0, true);</span>
    }

    /**
     * Returns the (zero-based) index of the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do match - see
     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code -1}.
     * A {@code null} type returns {@code -1}.
     * No match in the chain returns {@code -1}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code -1}.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     * @since 2.1
     */
    public static int indexOfType(final Throwable throwable, final Class&lt;? extends Throwable&gt; type, final int fromIndex) {
<span class="fc" id="L484">        return indexOf(throwable, type, fromIndex, true);</span>
    }

    /**
     * Checks if a throwable represents a checked exception
     *
     * @param throwable
     *            The throwable to check.
     * @return True if the given Throwable is a checked exception.
     * @since 3.13.0
     */
    public static boolean isChecked(final Throwable throwable) {
<span class="fc bfc" id="L496" title="All 6 branches covered.">        return throwable != null &amp;&amp; !(throwable instanceof Error) &amp;&amp; !(throwable instanceof RuntimeException);</span>
    }

    /**
     * Checks if a throwable represents an unchecked exception
     *
     * @param throwable
     *            The throwable to check.
     * @return True if the given Throwable is an unchecked exception.
     * @since 3.13.0
     */
    public static boolean isUnchecked(final Throwable throwable) {
<span class="fc bfc" id="L508" title="All 6 branches covered.">        return throwable != null &amp;&amp; (throwable instanceof Error || throwable instanceof RuntimeException);</span>
    }

    /**
     * Prints a compact stack trace for the root cause of a throwable
     * to {@code System.err}.
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to {@code printStackTrace} for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output
     * @since 2.0
     */
    public static void printRootCauseStackTrace(final Throwable throwable) {
<span class="fc" id="L530">        printRootCauseStackTrace(throwable, System.err);</span>
<span class="fc" id="L531">    }</span>

    /**
     * Prints a compact stack trace for the root cause of a throwable.
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to {@code printStackTrace} for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output, may be null
     * @param printStream  the stream to output to, may not be null
     * @throws NullPointerException if the printStream is {@code null}
     * @since 2.0
     */
    @SuppressWarnings(&quot;resource&quot;)
    public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream printStream) {
<span class="fc bfc" id="L554" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L555">            return;</span>
        }
<span class="fc" id="L557">        Objects.requireNonNull(printStream, &quot;printStream&quot;);</span>
<span class="fc" id="L558">        getRootCauseStackTraceList(throwable).forEach(printStream::println);</span>
<span class="fc" id="L559">        printStream.flush();</span>
<span class="fc" id="L560">    }</span>

    /**
     * Prints a compact stack trace for the root cause of a throwable.
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to {@code printStackTrace} for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output, may be null
     * @param printWriter  the writer to output to, may not be null
     * @throws NullPointerException if the printWriter is {@code null}
     * @since 2.0
     */
    @SuppressWarnings(&quot;resource&quot;)
    public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter printWriter) {
<span class="fc bfc" id="L583" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L584">            return;</span>
        }
<span class="fc" id="L586">        Objects.requireNonNull(printWriter, &quot;printWriter&quot;);</span>
<span class="fc" id="L587">        getRootCauseStackTraceList(throwable).forEach(printWriter::println);</span>
<span class="fc" id="L588">        printWriter.flush();</span>
<span class="fc" id="L589">    }</span>

    /**
     * Removes common frames from the cause trace given the two stack traces.
     *
     * @param causeFrames  stack trace of a cause throwable
     * @param wrapperFrames  stack trace of a wrapper throwable
     * @throws NullPointerException if either argument is null
     * @since 2.0
     */
    public static void removeCommonFrames(final List&lt;String&gt; causeFrames, final List&lt;String&gt; wrapperFrames) {
<span class="fc" id="L600">        Objects.requireNonNull(causeFrames, &quot;causeFrames&quot;);</span>
<span class="fc" id="L601">        Objects.requireNonNull(wrapperFrames, &quot;wrapperFrames&quot;);</span>
<span class="fc" id="L602">        int causeFrameIndex = causeFrames.size() - 1;</span>
<span class="fc" id="L603">        int wrapperFrameIndex = wrapperFrames.size() - 1;</span>
<span class="fc bfc" id="L604" title="All 4 branches covered.">        while (causeFrameIndex &gt;= 0 &amp;&amp; wrapperFrameIndex &gt;= 0) {</span>
            // Remove the frame from the cause trace if it is the same
            // as in the wrapper trace
<span class="fc" id="L607">            final String causeFrame = causeFrames.get(causeFrameIndex);</span>
<span class="fc" id="L608">            final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">            if (causeFrame.equals(wrapperFrame)) {</span>
<span class="fc" id="L610">                causeFrames.remove(causeFrameIndex);</span>
            }
<span class="fc" id="L612">            causeFrameIndex--;</span>
<span class="fc" id="L613">            wrapperFrameIndex--;</span>
<span class="fc" id="L614">        }</span>
<span class="fc" id="L615">    }</span>

    /**
     * Throws the given (usually checked) exception without adding the exception to the throws
     * clause of the calling method. This method prevents throws clause
     * inflation and reduces the clutter of &quot;Caused by&quot; exceptions in the
     * stack trace.
     * &lt;p&gt;
     * The use of this technique may be controversial, but useful.
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  // There is no throws clause in the method signature.
     *  public int propagateExample() {
     *      try {
     *          // throws SomeCheckedException.
     *          return invocation();
     *      } catch (SomeCheckedException e) {
     *          // Propagates a checked exception and compiles to return an int.
     *          return ExceptionUtils.rethrow(e);
     *      }
     *  }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * This is an alternative to the more conservative approach of wrapping the
     * checked exception in a RuntimeException:
     * &lt;/p&gt;
     * &lt;pre&gt;
     *  // There is no throws clause in the method signature.
     *  public int wrapExample() {
     *      try {
     *          // throws IOException.
     *          return invocation();
     *      } catch (Error e) {
     *          throw e;
     *      } catch (RuntimeException e) {
     *          // Throws an unchecked exception.
     *          throw e;
     *      } catch (Exception e) {
     *          // wraps a checked exception.
     *          throw new UndeclaredThrowableException(e);
     *      }
     *  }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * One downside to using this approach is that the Java compiler will not
     * allow invoking code to specify a checked exception in a catch clause
     * unless there is some code path within the try block that has invoked a
     * method declared with that checked exception. If the invoking site wishes
     * to catch the shaded checked exception, it must either invoke the shaded
     * code through a method re-declaring the desired checked exception, or
     * catch Exception and use the {@code instanceof} operator. Either of these
     * techniques are required when interacting with non-Java JVM code such as
     * Jython, Scala, or Groovy, since these languages do not consider any
     * exceptions as checked.
     * &lt;/p&gt;
     *
     * @param throwable
     *            The throwable to rethrow.
     * @param &lt;T&gt; The type of the return value.
     * @return Never actually returns, this generic type matches any type
     *         which the calling site requires. &quot;Returning&quot; the results of this
     *         method, as done in the propagateExample above, will satisfy the
     *         Java compiler requirement that all code paths return a value.
     * @since 3.5
     * @see #wrapAndThrow(Throwable)
     */
    public static &lt;T&gt; T rethrow(final Throwable throwable) {
        // claim that the typeErasure invocation throws a RuntimeException
<span class="nc" id="L683">        return ExceptionUtils.&lt;T, RuntimeException&gt;eraseType(throwable);</span>
    }

    /**
     * Streams causes of a Throwable.
     * &lt;p&gt;
     * A throwable without cause will return a stream containing one element - the input throwable. A throwable with one cause
     * will return a stream containing two elements. - the input throwable and the cause throwable. A {@code null} throwable
     * will return a stream of count zero.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This method handles recursive cause chains that might otherwise cause infinite loops. The cause chain is
     * processed until the end, or until the next item in the chain is already in the result.
     * &lt;/p&gt;
     *
     * @param throwable The Throwable to traverse
     * @return A new Stream of Throwable causes.
     * @since 3.13.0
     */
    public static Stream&lt;Throwable&gt; stream(final Throwable throwable) {
        // No point building a custom Iterable as it would keep track of visited elements to avoid infinite loops
<span class="fc" id="L705">        return getThrowableList(throwable).stream();</span>
    }

    /**
     * Worker method for the {@code throwableOfType} methods.
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search, subclasses match, null returns null
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns null
     * @param subclass if {@code true}, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares
     * using references
     * @return throwable of the {@code type} within throwables nested within the specified {@code throwable}
     */
    private static &lt;T extends Throwable&gt; T throwableOf(final Throwable throwable, final Class&lt;T&gt; type, int fromIndex, final boolean subclass) {
<span class="fc bfc" id="L721" title="All 4 branches covered.">        if (throwable == null || type == null) {</span>
<span class="fc" id="L722">            return null;</span>
        }
<span class="fc bfc" id="L724" title="All 2 branches covered.">        if (fromIndex &lt; 0) {</span>
<span class="fc" id="L725">            fromIndex = 0;</span>
        }
<span class="fc" id="L727">        final Throwable[] throwables = getThrowables(throwable);</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">        if (fromIndex &gt;= throwables.length) {</span>
<span class="fc" id="L729">            return null;</span>
        }
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (subclass) {</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">                if (type.isAssignableFrom(throwables[i].getClass())) {</span>
<span class="fc" id="L734">                    return type.cast(throwables[i]);</span>
                }
            }
        } else {
<span class="fc bfc" id="L738" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">                if (type.equals(throwables[i].getClass())) {</span>
<span class="fc" id="L740">                    return type.cast(throwables[i]);</span>
                }
            }
        }
<span class="fc" id="L744">        return null;</span>
    }

    /**
     * Returns the first {@link Throwable}
     * that matches the specified class (exactly) in the exception chain.
     * Subclasses of the specified class do not match - see
     * {@link #throwableOfType(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfThrowable(final Throwable throwable, final Class&lt;T&gt; clazz) {
<span class="fc" id="L764">        return throwableOf(throwable, clazz, 0, false);</span>
    }

    /**
     * Returns the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do not match - see
     * {@link #throwableOfType(Throwable, Class, int)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns null
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfThrowable(final Throwable throwable, final Class&lt;T&gt; clazz, final int fromIndex) {
<span class="fc" id="L789">        return throwableOf(throwable, clazz, fromIndex, false);</span>
    }

    /**
     * Returns the throwable of the first {@link Throwable}
     * that matches the specified class or subclass in the exception chain.
     * Subclasses of the specified class do match - see
     * {@link #throwableOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfType(final Throwable throwable, final Class&lt;T&gt; type) {
<span class="fc" id="L809">        return throwableOf(throwable, type, 0, true);</span>
    }

    /**
     * Returns the first {@link Throwable}
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do match - see
     * {@link #throwableOfThrowable(Throwable, Class)} for the opposite.
     *
     * &lt;p&gt;A {@code null} throwable returns {@code null}.
     * A {@code null} type returns {@code null}.
     * No match in the chain returns {@code null}.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns {@code null}.&lt;/p&gt;
     *
     * @param &lt;T&gt; the type of Throwable you are searching.
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns null
     * @param fromIndex  the (zero-based) index of the starting position,
     *  negative treated as zero, larger than chain size returns null
     * @return the first matching throwable from the throwable chain, null if no match or null input
     * @since 3.10
     */
    public static &lt;T extends Throwable&gt; T throwableOfType(final Throwable throwable, final Class&lt;T&gt; type, final int fromIndex) {
<span class="fc" id="L834">        return throwableOf(throwable, type, fromIndex, true);</span>
    }

    /**
     * Tests whether the specified {@link Throwable} is unchecked and throws it if so.
     *
     * @param &lt;T&gt; The Throwable type.
     * @param throwable the throwable to test and throw or return.
     * @return the given throwable.
     * @since 3.13.0
     * @deprecated Use {@link #throwUnchecked(Throwable)}.
     */
    @Deprecated
    public static &lt;T&gt; T throwUnchecked(final T throwable) {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (throwable instanceof RuntimeException) {</span>
<span class="nc" id="L849">            throw (RuntimeException) throwable;</span>
        }
<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (throwable instanceof Error) {</span>
<span class="nc" id="L852">            throw (Error) throwable;</span>
        }
<span class="nc" id="L854">        return throwable;</span>
    }

    /**
     * Tests whether the specified {@link Throwable} is unchecked and throws it if so.
     *
     * @param &lt;T&gt; The Throwable type.
     * @param throwable the throwable to test and throw or return.
     * @return the given throwable.
     * @since 3.14.0
     */
    public static &lt;T extends Throwable&gt; T throwUnchecked(final T throwable) {
<span class="fc bfc" id="L866" title="All 2 branches covered.">        if (isUnchecked(throwable)) {</span>
<span class="nc" id="L867">            throw asRuntimeException(throwable);</span>
        }
<span class="fc" id="L869">        return throwable;</span>
    }

    /**
     * Throws a checked exception without adding the exception to the throws
     * clause of the calling method. For checked exceptions, this method throws
     * an UndeclaredThrowableException wrapping the checked exception. For
     * Errors and RuntimeExceptions, the original exception is rethrown.
     * &lt;p&gt;
     * The downside to using this approach is that invoking code which needs to
     * handle specific checked exceptions must sniff up the exception chain to
     * determine if the caught exception was caused by the checked exception.
     * &lt;/p&gt;
     *
     * @param throwable
     *            The throwable to rethrow.
     * @param &lt;R&gt; The type of the returned value.
     * @return Never actually returned, this generic type matches any type
     *         which the calling site requires. &quot;Returning&quot; the results of this
     *         method will satisfy the Java compiler requirement that all code
     *         paths return a value.
     * @since 3.5
     * @see #asRuntimeException(Throwable)
     * @see #hasCause(Throwable, Class)
     */
    public static &lt;R&gt; R wrapAndThrow(final Throwable throwable) {
<span class="fc" id="L895">        throw new UndeclaredThrowableException(throwUnchecked(throwable));</span>
    }

    /**
     * Public constructor allows an instance of {@link ExceptionUtils} to be created, although that is not
     * normally necessary.
     *
     * @deprecated TODO Make private in 4.0.
     */
    @Deprecated
<span class="fc" id="L905">    public ExceptionUtils() {</span>
        // empty
<span class="fc" id="L907">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>